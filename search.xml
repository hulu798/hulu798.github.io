<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cursor rules</title>
    <url>/2025/03/31/Cursor-rules/</url>
    <content><![CDATA[<p>By default, all responses must be in Chinese.</p>
<h1 id="ai-full-stack-development-assistant-guide">AI Full-Stack
Development Assistant Guide</h1>
<h2 id="core-thinking-patterns">Core Thinking Patterns</h2>
<p>You must engage in multi-dimensional deep thinking before and during
responses:</p>
<h3 id="fundamental-thinking-modes">Fundamental Thinking Modes</h3>
<ul>
<li>Systems Thinking: Three-dimensional thinking from overall
architecture to specific implementation</li>
<li>Dialectical Thinking: Weighing pros and cons of multiple
solutions<br />
</li>
<li>Creative Thinking: Breaking through conventional thinking patterns
to find innovative solutions</li>
<li>Critical Thinking: Multi-angle validation and optimization of
solutions</li>
</ul>
<h3 id="thinking-balance">Thinking Balance</h3>
<ul>
<li>Balance between analysis and intuition</li>
<li>Balance between detailed inspection and global perspective<br />
</li>
<li>Balance between theoretical understanding and practical
application</li>
<li>Balance between deep thinking and forward momentum</li>
<li>Balance between complexity and clarity</li>
</ul>
<h3 id="analysis-depth-control">Analysis Depth Control</h3>
<ul>
<li>Conduct in-depth analysis for complex problems</li>
<li>Keep simple issues concise and efficient</li>
<li>Ensure analysis depth matches problem importance</li>
<li>Find balance between rigor and practicality</li>
</ul>
<h3 id="goal-focus">Goal Focus</h3>
<ul>
<li>Maintain clear connection with original requirements</li>
<li>Guide divergent thinking back to the main topic timely</li>
<li>Ensure related explorations serve the core objective</li>
<li>Balance between open exploration and goal orientation</li>
</ul>
<p>All thinking processes must: 0. Presented in the form of a block of
code + the title of the point of view, please note that the format is
strictly adhered to and that it must include a beginning and an end. 1.
Unfold in an original, organic, stream-of-consciousness manner 2.
Establish organic connections between different levels of thinking 3.
Flow naturally between elements, ideas, and knowledge 4. Each thought
process must maintain contextual records, keeping contextual
associations and connections</p>
<h2 id="technical-capabilities">Technical Capabilities</h2>
<h3 id="core-competencies">Core Competencies</h3>
<ul>
<li>Systematic technical analysis thinking</li>
<li>Strong logical analysis and reasoning abilities<br />
</li>
<li>Strict answer verification mechanism</li>
<li>Comprehensive full-stack development experience</li>
</ul>
<h3 id="adaptive-analysis-framework">Adaptive Analysis Framework</h3>
<p>Adjust analysis depth based on: - Technical complexity - Technology
stack scope - Time constraints<br />
- Existing technical information - User’s specific needs</p>
<h3 id="solution-process">Solution Process</h3>
<ol type="1">
<li>Initial Understanding</li>
</ol>
<ul>
<li>Restate technical requirements</li>
<li>Identify key technical points</li>
<li>Consider broader context</li>
<li>Map known/unknown elements</li>
</ul>
<ol start="2" type="1">
<li>Problem Analysis<br />
</li>
</ol>
<ul>
<li>Break down tasks into components</li>
<li>Determine requirements</li>
<li>Consider constraints</li>
<li>Define success criteria</li>
</ul>
<ol start="3" type="1">
<li>Solution Design</li>
</ol>
<ul>
<li>Consider multiple implementation paths</li>
<li>Evaluate architectural approaches</li>
<li>Maintain open-minded thinking</li>
<li>Progressively refine details</li>
</ul>
<ol start="4" type="1">
<li>Implementation Verification</li>
</ol>
<ul>
<li>Test assumptions</li>
<li>Verify conclusions</li>
<li>Validate feasibility</li>
<li>Ensure completeness</li>
</ul>
<h2 id="output-requirements">Output Requirements</h2>
<h3 id="code-quality-standards">Code Quality Standards</h3>
<ul>
<li>Always show complete code context for better understanding and
maintainability.</li>
<li>Code accuracy and timeliness</li>
<li>Complete functionality</li>
<li>Security mechanisms</li>
<li>Excellent readability</li>
<li>Use markdown formatting</li>
<li>Specify language and path in code blocks</li>
<li>Show only necessary code modifications #### Code Handling
Guidelines</li>
</ul>
<ol type="1">
<li>When editing code:
<ul>
<li>Show only necessary modifications</li>
<li>Include file paths and language identifiers</li>
<li>Provide context with comments</li>
<li>Format: ```language:path/to/file</li>
</ul></li>
<li>Code block structure:
<code>language:file/path    // ... existing code ...    &#123;&#123; modifications &#125;&#125;    // ... existing code ...</code></li>
</ol>
<h3 id="technical-specifications">Technical Specifications</h3>
<ul>
<li>Complete dependency management</li>
<li>Standardized naming conventions</li>
<li>Thorough testing</li>
<li>Detailed documentation</li>
</ul>
<h3 id="communication-guidelines">Communication Guidelines</h3>
<ul>
<li>Clear and concise expression</li>
<li>Handle uncertainties honestly</li>
<li>Acknowledge knowledge boundaries</li>
<li>Avoid speculation</li>
<li>Maintain technical sensitivity</li>
<li>Track latest developments</li>
<li>Optimize solutions</li>
<li>Improve knowledge</li>
</ul>
<h3 id="prohibited-practices">Prohibited Practices</h3>
<ul>
<li>Using unverified dependencies</li>
<li>Leaving incomplete functionality</li>
<li>Including untested code</li>
<li>Using outdated solutions</li>
</ul>
<h2 id="important-notes">Important Notes</h2>
<ul>
<li>Maintain systematic thinking for solution completeness</li>
<li>Focus on feasibility and maintainability</li>
<li>Continuously optimize interaction experience</li>
<li>Keep open learning attitude and updated knowledge</li>
<li>Disable the output of emoji unless specifically requested</li>
<li>By default, all responses must be in Chinese.</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>资源分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler</title>
    <url>/2025/03/31/Compiler/</url>
    <content><![CDATA[<ul>
<li><a href="/files/GCC编译器.pdf">GCC编译器</a>-GCC编译器简介</li>
<li><a href="https://gcc.gnu.org/">GCC官网</a></li>
</ul>
<h1 id="编译和链接">编译和链接</h1>
<figure>
<img data-src="/images/Compiler/20250331224528_001.jpg"
alt="编译链接流程图" />
<figcaption aria-hidden="true">编译链接流程图</figcaption>
</figure>
<h2 id="预处理指令的处理预编译">1. 预处理指令的处理(预编译)</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>   <span class="comment">//预处理后会把stdio.h的所有内容替换这个包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> a 100       <span class="comment">//预处理后会把以后的所有a全部替换为100</span></span></span><br></pre></td></tr></table></figure>
<p><mark><strong>用<code>gcc</code>编译器查看预处理指令情况</strong></mark></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">gcc -E .c源文件路径 -o ouputfile.i</span><br><span class="line">指令每次只能预处理单个文件</span><br></pre></td></tr></table></figure>
<p>附</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编译阶段选项：</span><br><span class="line">-E：仅进行预处理，不进行编译、汇编或链接。预处理会展开头文件、宏等。(!大写-E)</span><br><span class="line">-S：进行编译，但不进行汇编或链接，生成汇编代码。                 (!大写-S)   </span><br><span class="line">-c：进行汇编，但不进行链接，生成目标文件（.o 文件）。</span><br><span class="line">-o &lt;file&gt;：将输出放置到 &lt;file&gt; 中，可以是预处理后的文件、汇编文件、目标文件或可执行文件</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="/images/Compiler/20250331224529_002.png" alt="预处理示例" />
<figcaption aria-hidden="true">预处理示例</figcaption>
</figure>
<blockquote>
<p>[!note]</p>
<ul>
<li><mark>如果头文件里面包含其他头文件,这个包含的头文件也会被替代,即递归进行</mark></li>
</ul>
</blockquote>
<h2 id="编译">2.编译</h2>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">gcc -S test.i -o test.s  //将C语言代码转换为汇编代码(大写-S)</span><br><span class="line">也只能处理单个文件</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="/images/Compiler/20250331224530_003.png"
alt="编译过程示例1" />
<figcaption aria-hidden="true">编译过程示例1</figcaption>
</figure>
<figure>
<img data-src="/images/Compiler/20250331224532_004.png"
alt="编译过程示例2" />
<figcaption aria-hidden="true">编译过程示例2</figcaption>
</figure>
<figure>
<img data-src="/images/Compiler/20250331224533_005.png"
alt="编译过程示例3" />
<figcaption aria-hidden="true">编译过程示例3</figcaption>
</figure>
<figure>
<img data-src="/images/Compiler/20250331224535_006.png"
alt="编译过程示例4" />
<figcaption aria-hidden="true">编译过程示例4</figcaption>
</figure>
<h2 id="汇编">3.汇编</h2>
<figure>
<img data-src="/images/Compiler/20250331224537_007.png" alt="汇编过程示例" />
<figcaption aria-hidden="true">汇编过程示例</figcaption>
</figure>
<blockquote>
<p>[!important]</p>
<p><mark>汇编过程每一个.c源文件都会形成一个目标文件和相应的符号表(记录全局变量名,函数名等符号名的作用),链接过程会合并和重定位所有的符号表</mark></p>
</blockquote>
<pre class="mermaid">---
title: 链接过程
---
graph TD
    第一个目标文件.o-->|链接|可执行文件
    第二个目标文件.o-->|链接|可执行文件
    链接库-->|链接|可执行文件
    形成一个符号表</pre>
<h2 id="链接">4.链接</h2>
<figure>
<img data-src="/images/Compiler/20250331224538_008.png" alt="链接过程示例" />
<figcaption aria-hidden="true">链接过程示例</figcaption>
</figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">gcc file_1.o file_2.o -o outputFile</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">一条指令完成预处理编译汇编链接</span><br><span class="line">gcc file1.c file2.c -o output</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[!warning]</p>
<ul>
<li><p><strong><mark>预处理编译汇编每次只能处理一个文件,如果有多个文件需要分别处理得到目标文件.o在链接成可执行文件,这是因为-o生成文件每次只能生成一个文件</mark></strong></p></li>
<li><p>预处理编译汇编过程只能单个文件编译,但是可以从某一个过程直接跳跃到链接:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">gcc file1.i file2.i -o output</span><br><span class="line">因为链接后只生成一个文件,预处理编译汇编过程同时处理多个文件需要生成多个文件与-o一次只能生成一个文件矛盾了!</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<pre class="mermaid">---
title: 编译与链接
---
graph LR
    预处理-E生成.i文件-->编译-S生成.s文件-->汇编-c生成.o目标文件-->链接</pre>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">保留中间文件编译指令:</span><br><span class="line">gcc file.c -o file -save-temps</span><br></pre></td></tr></table></figure>
<h2 id="补充">补充</h2>
<h3 id="编码问题">编码问题</h3>
<ul>
<li><p>编程环境通常的用的字符字符编码是UTF-(chcp 65001)</p></li>
<li><p>而在Windows系统中字符编码是GBK(chcp 936)</p>
<p>两种格式不一样导致乱码</p></li>
</ul>
<blockquote>
<p>[!note]</p>
<p>解决方法</p>
<ol type="1">
<li><p>把编程环境改为GBK编码形式</p></li>
<li><p>把Windows终端改为UTF-8编码格式</p></li>
<li><p>指令形式编译,再编译过程加入字符编码处理</p></li>
</ol>
<p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">gcc test.c -finput-charset=utf-<span class="number">8</span> -fexec-charset=gbk  //charsets是字符集的意思</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure>
<img data-src="/images/Compiler/20250331224539_009.png" alt="编码问题示例" />
<figcaption aria-hidden="true">编码问题示例</figcaption>
</figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>GCC Compiler</tag>
        <tag>技术笔记</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现终端扫雷游戏</title>
    <url>/2025/04/29/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="数组和函数实践扫雷游戏">数组和函数实践：扫雷游戏</h1>
<h2 id="前言">前言</h2>
<p>扫雷是一款经典的单人益智游戏，它不仅具有很高的娱乐性，也是初学者练习C语言编程能力的绝佳项目。通过实现扫雷游戏，我们可以深入理解数组操作、函数设计、随机数生成等C语言核心知识点。本文将带您从零开始，一步步实现一个完整的终端扫雷游戏。</p>
<h2 id="扫雷游戏分析和设计">扫雷游戏分析和设计</h2>
<h3 id="扫雷游戏的功能说明">扫雷游戏的功能说明</h3>
<ul>
<li><p>使⽤控制台实现经典的扫雷游戏</p></li>
<li><p>游戏可以通过菜单实现继续玩或者退出游戏</p></li>
<li><p>扫雷的棋盘是9×9的格⼦</p></li>
<li><p>默认随机布置10个雷</p></li>
<li><p>可以排查雷</p>
<p>◦ 如果位置不是雷，就显⽰周围有⼏个雷</p>
<p>◦ 如果位置是雷，就炸死游戏结束</p>
<p>◦ 把除10个雷之外的所有⾮雷都找出来，排雷成功，游戏结束</p></li>
</ul>
<h3 id="可拓展功能">可拓展功能</h3>
<ul>
<li>游戏难度选择
<ul>
<li>简单：9×9 棋盘，10个雷</li>
<li>中等：16×16 棋盘，40个雷</li>
<li>困难：30×16 棋盘，99个雷</li>
</ul></li>
<li>空白区域自动展开：如果排查位置不是雷，周围也没有雷，可以展开周围的⼀⽚</li>
<li>标记功能：允许玩家标记可能是雷的位置</li>
<li>计时功能：记录排雷的时间</li>
</ul>
<h2 id="游戏的分析和设计">游戏的分析和设计</h2>
<h3 id="数据结构的分析">数据结构的分析</h3>
<p>扫雷的过程中，布置的雷和排查出的雷的信息都需要存储，所以我们需要⼀定的数据结构来存储这些信息。因为我们需要9×9的棋盘上布置雷的信息和排查雷，我们⾸先想到的就是创建⼀个9×9的数组来存放信息。</p>
<figure>
<img data-src="/images/C语言实现终端扫雷游戏/20250429225226_001.png"
alt="扫雷棋盘示意图" />
<figcaption aria-hidden="true">扫雷棋盘示意图</figcaption>
</figure>
<p>那如果这个位置布置雷，我们就存放1，没有布置雷就存放0。</p>
<figure>
<img data-src="/images/C语言实现终端扫雷游戏/20250429225227_002.png"
alt="雷的布置示意图" />
<figcaption aria-hidden="true">雷的布置示意图</figcaption>
</figure>
<blockquote>
<p>假设我们排查(2,5)这个坐标时，我们访问周围的⼀圈8个⻩⾊位置，统计周围雷的个数是1</p>
<p>假设我们排查(8,6)这个坐标时，我们访问周围的⼀圈8个⻩⾊位置，统计周围雷的个数时，最下⾯的三个坐标就会越界，为了防⽌越界，我们在设计的时候，给数组扩⼤⼀圈，雷还是布置在中间的9×9的坐标上，周围⼀圈不去布置雷就⾏，这样就解决了越界的问题。所以我们将存放数据的数组创建成11×11是⽐较合适。</p>
</blockquote>
<figure>
<img data-src="/images/C语言实现终端扫雷游戏/20250429225228_003.png"
alt="边界处理示意图" />
<figcaption aria-hidden="true">边界处理示意图</figcaption>
</figure>
<figure>
<img data-src="/images/C语言实现终端扫雷游戏/20250429225229_004.png"
alt="扩展棋盘示意图" />
<figcaption aria-hidden="true">扩展棋盘示意图</figcaption>
</figure>
<blockquote>
<p>再继续分析，我们在棋盘上布置了雷，棋盘上雷的信息（1）和⾮雷的信息（0），假设我们排查了某⼀个位置后，这个坐标处不是雷，这个坐标的周围有1个雷，那我们需要将排查出的雷的数量信息记录存储，并打印出来，作为排雷的重要参考信息的。那这个雷的个数信息存放在哪⾥呢？如果存放在布置雷的数组中，这样雷的信息和雷的个数信息就可能或产⽣混淆和打印上的困难。这⾥我们肯定有办法解决，⽐如：雷和⾮雷的信息不要使⽤数字，使⽤某些字符就⾏，这样就避免冲突了，但是这样做棋盘上有雷和⾮雷的信息，还有排查出的雷的个数信息，就⽐较混杂，不够⽅便。</p>
<p>这⾥我们采⽤另外⼀种⽅案，我们专⻔给⼀个棋盘（对应⼀个数组mine）存放布置好的雷的信息，再给另外⼀个棋盘（对应另外⼀个数组printBoard）存放排查出的雷的信息。这样就互不⼲扰了，把雷布置到mine数组，在mine数组中排查雷，排查出的数据存放在show数组，并且打印show数组的信息给后期排查参考。同时为了保持神秘，show数组开始时初始化为字符
’*‘，为了保持两个数组的类型⼀致，可以使⽤同⼀套函数处理，mine数组最开始也初始化为字符’0’，布置雷改成’1’。如下如：</p>
</blockquote>
<figure>
<img data-src="/images/C语言实现终端扫雷游戏/20250429225229_005.png"
alt="双数组示意图" />
<figcaption aria-hidden="true">双数组示意图</figcaption>
</figure>
<figure>
<img data-src="/images/C语言实现终端扫雷游戏/20250429225230_006.png"
alt="数组存储示意图" />
<figcaption aria-hidden="true">数组存储示意图</figcaption>
</figure>
<h3 id="文件结构设计">文件结构设计</h3>
<p>为了使代码结构清晰，我们将扫雷游戏分为三个文件：</p>
<ol type="1">
<li><code>game.h</code> - 头文件，包含函数声明和宏定义</li>
<li><code>game.c</code> - 源文件，包含游戏逻辑实现</li>
<li><code>main.c</code> - 主文件，包含主函数和菜单功能</li>
</ol>
<h2 id="游戏代码实现">游戏代码实现</h2>
<h3 id="头文件实现game.h">头文件实现（game.h）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义游戏棋盘大小,便于后期拓展</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS (ROW + 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLS (COL + 2)</span></span><br><span class="line"><span class="comment">// 定义雷的数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏进行函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initBoard</span><span class="params">(<span class="type">char</span> (*arr)[COLS], <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> setchar)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> (*arr)[COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机数布置雷</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setMine</span><span class="params">(<span class="type">char</span> (*arr)[COLS], <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排雷</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findMine</span><span class="params">(<span class="type">char</span> (*arr)[COLS], <span class="type">char</span> (*printBoard)[COLS], <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>
<p>头文件中，我们定义了游戏所需的常量和函数声明：</p>
<ol type="1">
<li><code>ROW</code>和<code>COL</code>定义了游戏棋盘的实际大小（9×9）</li>
<li><code>ROWS</code>和<code>COLS</code>则是在实际棋盘外围增加一圈边界（11×11）</li>
<li><code>COUNT</code>定义了雷的数量（10个）</li>
<li>声明了游戏所需的各个函数</li>
</ol>
<h3 id="主函数实现main.c">主函数实现（main.c）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;game.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetConsoleOutputCP(<span class="number">65001</span>);</span><br><span class="line">    <span class="comment">//设置随机数种子</span></span><br><span class="line">    srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> play = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please choose:&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;play);</span><br><span class="line">        <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">switch</span> (play)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            game();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;EXIT!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (play);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*********1. play********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*********0. exit********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;************************\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数中，我们实现了：</p>
<ol type="1">
<li>菜单显示功能 - 让用户选择”开始游戏”或”退出游戏”</li>
<li>设置控制台支持UTF-8编码（<code>SetConsoleOutputCP(65001)</code>）</li>
<li>根据系统时间初始化随机数种子</li>
<li>用户输入处理和游戏流程控制</li>
</ol>
<h3 id="游戏逻辑实现game.c">游戏逻辑实现（game.c）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;game.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏进行函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------game-------\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> mine[ROWS][COLS] = &#123;<span class="number">0</span>&#125;, printBoard[ROWS][COLS] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    initBoard(mine, ROWS, COLS, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    initBoard(printBoard, ROWS, COLS, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">//布雷</span></span><br><span class="line">    setMine(mine, ROWS, COLS, COUNT);</span><br><span class="line">    <span class="comment">//打印游戏面板</span></span><br><span class="line">    print(printBoard, ROWS, COLS);</span><br><span class="line">    <span class="comment">//排雷</span></span><br><span class="line">    findMine(mine, printBoard, ROWS, COLS, COUNT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initBoard</span><span class="params">(<span class="type">char</span> (*arr)[COLS], <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> setchar)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            arr[i][j] = setchar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> (*arr)[COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印列号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; col - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印行号和棋盘内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; col - <span class="number">1</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, arr[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机数布置雷</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setMine</span><span class="params">(<span class="type">char</span> (*arr)[COLS], <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (count != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = rand() % ROW + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> y = rand() % COL + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[x][y] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排雷</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findMine</span><span class="params">(<span class="type">char</span> (*arr)[COLS], <span class="type">char</span> (*printBoard)[COLS], <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 记录已经排查的非雷格子数量</span></span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> totalToFind = ROW * COL - COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入要排查的坐标(行 列):&gt;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查输入坐标是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; ROW || y &lt; <span class="number">1</span> || y &gt; COL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;坐标无效，请重新输入！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查该位置是否已经排查过</span></span><br><span class="line">        <span class="keyword">if</span> (printBoard[x][y] != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;该位置已经排查过，请重新输入！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否踩雷</span></span><br><span class="line">        <span class="keyword">if</span> (arr[x][y] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printBoard[x][y] = <span class="string">&#x27;X&#x27;</span>; <span class="comment">// 标记踩到的雷</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;很遗憾，踩雷了...\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;游戏结束!\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 显示所有雷的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= COL; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; printBoard[i][j] != <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                        printBoard[i][j] = <span class="string">&#x27;@&#x27;</span>; <span class="comment">// 显示其他雷的位置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            print(printBoard, ROWS, COLS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算周围雷的个数</span></span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                        sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新排查结果</span></span><br><span class="line">            printBoard[x][y] = sum + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            found++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印当前游戏面板</span></span><br><span class="line">            print(printBoard, ROWS, COLS);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断是否获胜</span></span><br><span class="line">            <span class="keyword">if</span> (found == totalToFind)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;恭喜你，成功排除所有雷！\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;游戏胜利!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>游戏逻辑实现中，我们定义了几个主要函数：</p>
<ol type="1">
<li><code>game()</code> -
游戏主控制函数，完成初始化、布雷和排雷的调用</li>
<li><code>initBoard()</code> - 初始化棋盘，将数组填充为指定字符</li>
<li><code>print()</code> - 打印棋盘，展示当前游戏状态</li>
<li><code>setMine()</code> - 随机布置雷，使用rand()生成随机坐标</li>
<li><code>findMine()</code> - 排雷函数，处理玩家输入和游戏逻辑</li>
</ol>
<h3 id="关键算法讲解">关键算法讲解</h3>
<ol type="1">
<li><p><strong>双数组设计</strong>：使用两个二维数组分别存储雷的位置和玩家可见的游戏面板，保证了数据的清晰分离。</p></li>
<li><p><strong>随机布雷算法</strong>： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setMine</span><span class="params">(<span class="type">char</span> (*arr)[COLS], <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (count != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = rand() % ROW + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> y = rand() % COL + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[x][y] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个算法通过随机生成1到ROW和1到COL的坐标，在保证不重复的情况下，在数组中标记雷的位置。</p></li>
<li><p><strong>周围雷数计算</strong>： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算周围雷的个数</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码通过遍历当前位置周围的8个格子，计算周围雷的数量。这就是为什么我们需要设计11×11的数组，以避免在边界位置检测时越界。</p></li>
</ol>
<h2 id="游戏运行效果">游戏运行效果</h2>
<p>游戏运行时，玩家首先看到菜单界面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">************************</span><br><span class="line">*********1. play********</span><br><span class="line">*********0. exit********</span><br><span class="line">************************</span><br><span class="line">Please choose:&gt;</span><br></pre></td></tr></table></figure>
<p>选择1进入游戏后，会看到初始的游戏界面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1 2 3 4 5 6 7 8 9 </span><br><span class="line">1 * * * * * * * * * </span><br><span class="line">2 * * * * * * * * * </span><br><span class="line">3 * * * * * * * * * </span><br><span class="line">4 * * * * * * * * * </span><br><span class="line">5 * * * * * * * * * </span><br><span class="line">6 * * * * * * * * * </span><br><span class="line">7 * * * * * * * * * </span><br><span class="line">8 * * * * * * * * * </span><br><span class="line">9 * * * * * * * * * </span><br><span class="line">请输入要排查的坐标(行 列):&gt;</span><br></pre></td></tr></table></figure>
<p>随着游戏的进行，玩家会逐渐揭开安全区域，数字表示周围有几个雷：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1 2 3 4 5 6 7 8 9 </span><br><span class="line">1 * * * * * * * * * </span><br><span class="line">2 * * * * * * * * * </span><br><span class="line">3 * * 1 1 1 * * * * </span><br><span class="line">4 * * 1 0 1 * * * * </span><br><span class="line">5 * * 1 1 1 * * * * </span><br><span class="line">6 * * * * * * * * * </span><br><span class="line">7 * * * * * * * * * </span><br><span class="line">8 * * * * * * * * * </span><br><span class="line">9 * * * * * * * * * </span><br><span class="line">请输入要排查的坐标(行 列):&gt;</span><br></pre></td></tr></table></figure>
<p>如果玩家踩到雷，游戏结束，会显示所有雷的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1 2 3 4 5 6 7 8 9 </span><br><span class="line">1 * * * * * * * * * </span><br><span class="line">2 * * * * * * * * * </span><br><span class="line">3 * * 1 1 1 * * * * </span><br><span class="line">4 * * 1 0 1 * * * * </span><br><span class="line">5 * * 1 1 1 * * * * </span><br><span class="line">6 * * * * * @ * * * </span><br><span class="line">7 * * * @ * * * * * </span><br><span class="line">8 * * * * * * @ * * </span><br><span class="line">9 * * * X * * * * @ </span><br><span class="line">很遗憾，踩雷了...</span><br><span class="line">游戏结束!</span><br></pre></td></tr></table></figure>
<p>成功排除所有非雷位置后，玩家获胜：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1 2 3 4 5 6 7 8 9 </span><br><span class="line">1 1 1 1 0 0 0 1 1 1 </span><br><span class="line">2 1 * 2 1 0 0 1 * 1 </span><br><span class="line">3 1 2 2 1 0 0 1 1 1 </span><br><span class="line">4 0 1 1 1 0 0 0 0 0 </span><br><span class="line">5 0 0 0 0 0 0 1 1 1 </span><br><span class="line">6 1 1 0 0 0 0 1 * 1 </span><br><span class="line">7 1 * 1 0 0 0 1 1 1 </span><br><span class="line">8 1 1 1 0 0 0 0 0 0 </span><br><span class="line">9 0 0 0 0 0 0 0 0 0 </span><br><span class="line">恭喜你，成功排除所有雷！</span><br><span class="line">游戏胜利!</span><br></pre></td></tr></table></figure>
<h2 id="代码优化和扩展功能实现思路">代码优化和扩展功能实现思路</h2>
<h3 id="空白区域自动展开">1. 空白区域自动展开</h3>
<p>当玩家点击的位置周围没有雷时，我们可以自动展开相邻的空白区域。实现思路是使用递归函数，当发现一个空白格子（周围雷数为0）时，自动展开它周围的格子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归展开空白区域</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expandBlank</span><span class="params">(<span class="type">char</span> (*mine)[COLS], <span class="type">char</span> (*printBoard)[COLS], <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> *pFound)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果当前位置已经展开或超出边界，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (printBoard[x][y] != <span class="string">&#x27;*&#x27;</span> || x &lt; <span class="number">1</span> || x &gt; ROW || y &lt; <span class="number">1</span> || y &gt; COL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算周围雷的个数</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mine[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新展开的格子数</span></span><br><span class="line">    (*pFound)++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示当前格子的周围雷数</span></span><br><span class="line">    printBoard[x][y] = count + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果周围没有雷，继续展开周围的格子</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 跳过当前格子</span></span><br><span class="line">                <span class="keyword">if</span> (i == x &amp;&amp; j == y)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                expandBlank(mine, printBoard, i, j, pFound);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标记功能">2. 标记功能</h3>
<p>允许玩家标记可能是雷的位置，需要在<code>findMine</code>函数中增加一个标记选项：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请选择操作：1.排查 2.标记 &gt;&quot;</span>);</span><br><span class="line"><span class="type">int</span> choice;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(choice) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 排查逻辑</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 标记逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (printBoard[x][y] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            printBoard[x][y] = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (printBoard[x][y] == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">            printBoard[x][y] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入有误，请重新选择\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="难度选择">3. 难度选择</h3>
<p>添加难度选择需要修改棋盘大小和雷数定义，可以在主菜单中添加难度选择：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> difficulty = <span class="number">1</span>; <span class="comment">// 默认简单难度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请选择难度：1.简单 2.中等 3.困难 &gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;difficulty);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(difficulty) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 简单：9×9，10个雷</span></span><br><span class="line">        ROW = <span class="number">9</span>; COL = <span class="number">9</span>; COUNT = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 中等：16×16，40个雷</span></span><br><span class="line">        ROW = <span class="number">16</span>; COL = <span class="number">16</span>; COUNT = <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 困难：30×16，99个雷</span></span><br><span class="line">        ROW = <span class="number">30</span>; COL = <span class="number">16</span>; COUNT = <span class="number">99</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;选择有误，使用默认难度(简单)\n&quot;</span>);</span><br><span class="line">        ROW = <span class="number">9</span>; COL = <span class="number">9</span>; COUNT = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计时功能">4. 计时功能</h3>
<p>添加计时功能可以使用<code>time.h</code>库中的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">time_t</span> start, end;</span><br><span class="line">time(&amp;start); <span class="comment">// 记录开始时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏逻辑...</span></span><br><span class="line"></span><br><span class="line">time(&amp;end); <span class="comment">// 记录结束时间</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;游戏用时：%.0f秒\n&quot;</span>, difftime(end, start));</span><br></pre></td></tr></table></figure>
<h2 id="项目总结">项目总结</h2>
<p>通过实现这个扫雷游戏项目，我们不仅创建了一个完整的游戏，更深入理解了以下C语言重要概念：</p>
<ol type="1">
<li><strong>二维数组的应用</strong>：使用二维数组表示游戏棋盘，实现了数据的高效存储和操作。</li>
<li><strong>函数设计与模块化</strong>：通过合理的函数划分，实现了代码的模块化和复用。</li>
<li><strong>随机数生成</strong>：学习了如何生成随机数并应用于游戏布局。</li>
<li><strong>递归算法</strong>：在扩展功能中，可以使用递归实现空白区域的自动展开。</li>
<li><strong>指针和数组参数传递</strong>：掌握了将二维数组作为参数传递给函数的方法。</li>
</ol>
<h2 id="学习建议">学习建议</h2>
<ol type="1">
<li><strong>理解游戏逻辑</strong>：深入理解扫雷游戏的核心逻辑，特别是周围雷数的计算和空白区域的自动展开。</li>
<li><strong>调试技巧</strong>：学会使用打印中间结果的方式来调试程序，如打印雷的分布情况。</li>
<li><strong>拓展练习</strong>：尝试实现文章中提到的扩展功能，如难度选择、自动展开、标记功能等。</li>
<li><strong>优化代码</strong>：思考如何优化算法，提高游戏运行效率，特别是在棋盘较大时。</li>
<li><strong>图形界面尝试</strong>：有兴趣的同学可以尝试使用图形库（如EasyX、SDL等）将游戏升级为图形界面版本。</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>技术笔记</tag>
        <tag>C语言</tag>
        <tag>游戏开发</tag>
        <tag>扫雷</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora-Notes</title>
    <url>/2025/03/31/Typora-Notes/</url>
    <content><![CDATA[<h2 id="markdown-notes"># MarkDown Notes</h2>
<h2 id="标题">1. 标题</h2>
<blockquote>
<ul>
<li><p><strong>#个数对应标题等级(#+空格)</strong></p></li>
<li><p><strong>ctrl+数字1~6可以快速将选中的文本调成对应级别标题</strong></p></li>
<li><p><strong>ctrl+0可以快速将选中文本调成普通文本</strong></p></li>
<li><p><strong>ctrl++/-可以对标题等级加减</strong></p></li>
</ul>
</blockquote>
<h2 id="段落">2. 段落</h2>
<h3 id="换行">换行</h3>
<blockquote>
<p><strong>1.enterkbd&gt;(大换行);</strong>
<strong>2.shift+回车;</strong>(小换行)
3.&lt;br&gt;或者&lt;br/&gt;(小换行)(再html格式内换行用,不然直接enter会断开html)</p>
</blockquote>
<p>第一行<br>第二行<br/>第三行</p>
<h3 id="分割线">分割线</h3>
<p><strong><mark>1.三个-号;(建议)</mark></strong></p>
<p>2.三个*号;</p>
<h3 id="文本设置html语法">文本设置(HTML语法)</h3>
<h4 id="字体颜色">1.字体颜色</h4>
<p><font color =red>1. 我是红色</font> <font color =green>2.
我是绿色</font> <font color = blue>3. 我是蓝色</font></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">颜色(EN)</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>[!tip]</p>
<p><strong>颜色可以填RGB编号:</strong><code>&lt;font color="#ED2DE4"&gt;颜色&lt;/font&gt;</code></p>
</blockquote>
</blockquote>
<h4 id="字号">2.字号</h4>
<blockquote>
<p><strong>说明:</strong>用size指定字体大小,数字是1~6,浏览器默认为3,允许小数</p>
</blockquote>
<p><font size=5 color=red>这是五号字体</font>
<font size=3 color=blue>这是三号字体</font>
<font size=1 color=green>这是一号字体</font></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">字号</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="字体">3.字体</h4>
<p><font face = "楷体">1.这是楷体</font>
<font face = "黑体">2.这是黑体</font>
<font face = "微软雅黑">3.这是微软雅黑</font>
<font face = "华文彩云">4.这是华文彩云</font>
<font face="STCAIYUN">5.这是华文彩云</font>
<font face="宋体">6.这是宋体</font>
<font face="华文行楷">7.这是华文行楷</font>
<font face="方正姚体">8.这是方正姚体</font>
<font face="幼圆">9.这是幼圆</font>
<font face="隶书">10.这是隶书</font></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span> = <span class="string">&quot;楷体&quot;</span>&gt;</span>1.这是楷体<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span> = <span class="string">&quot;黑体&quot;</span>&gt;</span>2.这是黑体<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span> = <span class="string">&quot;微软雅黑&quot;</span>&gt;</span>3.这是微软雅黑<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span> = <span class="string">&quot;华文彩云&quot;</span>&gt;</span>4.这是华文彩云<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;STCAIYUN&quot;</span>&gt;</span>5.这是华文彩云<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;宋体&quot;</span>&gt;</span>6.这是宋体<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;华文行楷&quot;</span>&gt;</span>7.这是华文行楷<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;方正姚体&quot;</span>&gt;</span>8.这是方正姚体<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;幼圆&quot;</span>&gt;</span>9.这是幼圆<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;隶书&quot;</span>&gt;</span>10.这是隶书<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="文本背景色">4.文本背景色</h4>
<table>
<tr>
<td bgcolor="pink">
这段文字的背景颜色是粉红色
</td>
</tr>
</table>
<table>
<tr>
<td bgcolor="yellow">
这段文字的背景颜色是黄色
</td>
</tr>
</table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">pink</span>&gt;</span> 这段文字的背景颜色是粉红色 <span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">yellow</span>&gt;</span> 这段文字的背景颜色是黄色 <span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="文本居中">5.文本居中</h4>
<center>
文本
</center>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="其他文本设置">6.其他文本设置</h4>
<blockquote>
<ul>
<li><p><strong>ctrl+B设置粗体字(两边各加两个)</strong></p></li>
<li><p><strong>ctrl+I设置斜体字(两边各加一个)</strong></p></li>
<li><p><strong>shift+Alt+5删除线(一对双飘号)</strong></p></li>
<li><p><strong>ctrl+U下划线(一对u标签包裹)</strong></p></li>
<li><p><strong>高亮(一对双等于号)</strong></p></li>
<li><p><strong>注释:</strong><code>&lt;!--我是注释--&gt;</code></p>
<p><mark>在编辑和预览时，注释的内容会被显示；在导出 PDF 或 Word
时，则会被隐藏</mark></p></li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**这是粗体**</span><br><span class="line">*这是斜体*</span><br><span class="line">~~这是删除线~~</span><br><span class="line">&lt;u&gt;这是下划线&lt;/u&gt;</span><br><span class="line">==这是高亮==</span><br><span class="line">&lt;!--我是注释--&gt; </span><br></pre></td></tr></table></figure>
<h3 id="上下标">上下标</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上标:a^b^</span><br><span class="line">下标:a~b~</span><br><span class="line">用Latex格式好看一点$a^&#123;b&#125;$   $a_&#123;b&#125;$</span><br></pre></td></tr></table></figure>
<h3 id="文本查找">文本查找</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">搜索:ctrl+F</span><br><span class="line">搜索+替换:ctrl+H//这里和VsCode类似</span><br></pre></td></tr></table></figure>
<h2 id="列表">3. 列表</h2>
<h3 id="无序列表">1. 无序列表</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置:*/-/+/+空格或者ctrl+shift+]</span><br><span class="line">ctrl+[和ctrl+]将列表等级升级和降级</span><br><span class="line">退出列表:两次回车退出一个等级列表,反复按回车键即可</span><br></pre></td></tr></table></figure>
<p>同级别:</p>
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
<p>子集类:(<mark><strong>Tab键下一级列表</strong></mark>)</p>
<ul>
<li>一级分类
<ul>
<li>二级分类
<ul>
<li>三级分类</li>
</ul></li>
</ul></li>
</ul>
<h3 id="有序列表">2. 有序列表</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置:数字+.+空格或者ctrl+shift+[</span><br><span class="line">退出和等级变换快捷键和无序列表一致</span><br></pre></td></tr></table></figure>
<h3 id="任务列表">3. 任务列表</h3>
<blockquote>
<ul class="task-list">
<li><p><label><input
type="checkbox" /><strong>早起</strong></label></p></li>
<li><p><label><input type="checkbox"
checked="" /><strong>晚睡</strong></label></p></li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-+空格[空格]+空格,实际上是无序列表+[空格]+空格</span><br><span class="line">-+空格[x]+空格,实际上是无序列表+[x]+空格</span><br><span class="line">升级降级退出方法和无序列表相同</span><br><span class="line">快捷键ctrl+shift+X</span><br></pre></td></tr></table></figure>
<h2 id="区块显示引用">4.区块显示(引用)</h2>
<blockquote>
<blockquote>

</blockquote>
<blockquote>
<blockquote>

</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;+空格</span><br><span class="line">&gt;+回车</span><br><span class="line">在输入完一个区块显示后直接回车会撤回(同上列表)</span><br><span class="line">ctrl+[和回车键可以取消前一个区块显示符号(和列表级别变换方法相同)</span><br><span class="line">如果想增加引用的行数:shift+enter</span><br><span class="line">&gt;+[!+类型]可以得到警告框,已有的类型是:note,tip,warning,important,caution</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[!note]</p>
<p><strong>这是提醒内容</strong></p>
</blockquote>
<h2 id="代码显示"><mark>5.代码显示</mark></h2>
<ul>
<li>行内代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`这是行内代码`</span><br></pre></td></tr></table></figure>
<ul>
<li>代码块</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入```+语言模式或者~~~加语言模式</span><br><span class="line">快捷键:选中代码+ctrl+shift+K</span><br></pre></td></tr></table></figure>
<h2 id="链接">6.链接</h2>
<h3 id="链接网址">1.链接网址</h3>
<h4 id="行内链接">行内链接</h4>
<ul>
<li><p><a href="http://github.com"
class="uri">http://github.com</a></p></li>
<li><p><a href="http://github.com">GitHub</a></p></li>
<li><p><a href="http://github.com" title="Github">GitHub</a></p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">网址</span><br><span class="line">&lt;网址&gt;与直接输入网址作用相同</span><br><span class="line">[名称]+(网址)</span><br><span class="line">[名称]+(网址+空格+&quot;网址&quot;)//将鼠标悬停显示备注</span><br><span class="line">ctrl+点击即可跳转</span><br></pre></td></tr></table></figure>
<h4 id="参考式">参考式</h4>
<p>参考式链接的写法相当于行内式拆分成两部分，并通过一个 识别符 来
连接两部分。<mark>参考式能尽量保持文章结构的简单，也方便统一管理<span
class="math inline">\(URL\)</span></mark></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[网址名字][标识符]</span><br><span class="line">[标识符]:空格+网址 &quot;说明(鼠标悬停)&quot;</span><br></pre></td></tr></table></figure>
<p><a href="http://github.com" title="代码托管平台">GitHub</a></p>
<h3 id="文章内链接锚点">2.文章内链接(锚点)</h3>
<p><a href="#1.%20标题" title="tip">标题</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[备注](#+标题名+空格+&quot;说明&quot;)//注意标题名要完整的标题包括空格</span><br><span class="line">[标题](#1.标题)//ctrl+点击跳转</span><br></pre></td></tr></table></figure>
<h3 id="链接文件">3.链接文件</h3>
<p><a href="C:\Users\Dell\Desktop\C\Code\跳过整数.png">code</a></p>
<p><a href="C:\Users\Dell\Desktop\组合优化与博弈论.pdf">book</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[自主命名](文件路径)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[!warning]</p>
<p><mark>链接本地文件其他设备打不开,可以上传文件到Gitee云端,再复制链接到<span
class="math inline">\(MarkDown\)</span>文件上面</mark></p>
</blockquote>
<h2 id="脚注">7.脚注</h2>
<p><strong>说明:对文本解释说明</strong></p>
<p>文本<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文本[^脚注]</span><br><span class="line">[^脚注]:内容</span><br><span class="line">如果内容太长要分为多行写,再分行的地方+&lt;br&gt;+就可以实现多行脚注说明(原文链接依然在最后面)</span><br></pre></td></tr></table></figure>
<h2 id="图片插入"><mark>8.图片插入</mark></h2>
<h3 id="行内插入">行内插入</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">![图片命名](链接)</span><br><span class="line">//链接可为本地路径或者网址(无论是哪一种路径都会上传gitee转化为gitee网址!!)</span><br><span class="line"> 即!+[自己命名图片]+(图片路径+空格+&quot;图片标题&quot;)或者!+[自己命名图片]+(图片网址+空格+&quot;图片标题&quot;)</span><br><span class="line"> 图片标题是当把鼠标放在图片上面显示的文字(这个功能只有链接网址和图片插入才有,文件链接没有这功能!!!)</span><br><span class="line"> (无论是哪一种路径都会上传gitee转化为gitee网址)</span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://gitee.com/hulu135289/helloworld/raw/master/微信图片_20240830133102.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;微信图片_20240830133102&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;小李睡了吗&quot;</span> /&gt;</span>加图片说明/标题格式</span><br><span class="line">(在设置了图片大小的时候用HTML格式输入)在没有调整图片大小的时候格式和上面![图片命名](链接+&quot;说明&quot;)一样</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/Typora-Notes/20250331231607_001.jpg" alt="微信图片_20240830133102" style="zoom:40%;" title="小李睡了吗" /></p>
<h3 id="参考式-1">参考式</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片命名][标识符]</span><br><span class="line">[标识符]:空格+网址+空格+&quot;鼠标悬梯说明&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[!tip]</p>
<ul>
<li>直接拖入视频也可以插入视频,但是这里插入的是路径和HTML语法,如果考虑迁移可以修改路径为Gitte网址:</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;xxx.mp4&quot;</span> /&gt;</span></span>    //拖动视频显示这个插入方式,这个时候把路径改为云端视频网址即可</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;/videos/hero-light-lg.webm&quot;</span> <span class="attr">autoplay</span> <span class="attr">muted</span> <span class="attr">playsinline</span> <span class="attr">loop</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line"><span class="bullet">1.</span> autoplay - 启用自动播放</span><br><span class="line"><span class="bullet">2.</span> muted - 静音播放（绕过浏览器限制）</span><br><span class="line"><span class="bullet">3.</span> playsinline - 支持移动设备内联播放</span><br><span class="line"><span class="bullet">4.</span> loop - 循环播放视频</span><br></pre></td></tr></table></figure>
<ul>
<li>插入音频</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;xxx.mp3&quot;</span> /&gt;</span></span>    //与上同理</span><br></pre></td></tr></table></figure>
</blockquote>
<video src="/videos/hero-light-lg.webm" autoplay muted playsinline loop>
</video>
<h2 id="表格">9.表格</h2>
<p>不建议使用源代码方式,建议采用快捷键<code>ctrl+T</code></p>
<table>
<thead>
<tr>
<th>第一行<br/>第二行<br/>第三行</th>
<th style="text-align: left;"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td style="text-align: left;"></td>
<td></td>
</tr>
<tr>
<td></td>
<td style="text-align: left;"></td>
<td></td>
</tr>
<tr>
<td></td>
<td style="text-align: left;"></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在表格一个空位输入多行:shift+enter或者&lt;br&gt;</span><br><span class="line">增加表格行数:ctrl+enter</span><br><span class="line">删除行:ctrl+shift+backspace</span><br></pre></td></tr></table></figure>
<h2 id="图表">10.图表</h2>
<blockquote>
<p><strong>Mermaid语法:</strong>在代码模式中使用mermaid语言即可
<strong><mark>Mermad官网教学文档:</mark></strong><a
href="https://mermaid.nodejs.cn/intro/"
title="Mermaid官网文档">点我</a></p>
</blockquote>
<h3 id="流程图">流程图</h3>
<blockquote>
<p>[!warning] 如果你使用字母 “o” 或 “x”
作为连接流程图节点的首字母，请在字母前添加空格或将字母大写（例如，<code>"dev--- ops"、"dev---Ops"</code>）。输入
“A—oB” 将创建 <a
href="https://mermaid.nodejs.cn/syntax/flowchart.html#circle-edge-example">circle
edge</a>。输入 “A—xB” 将创建 <a
href="https://mermaid.nodejs.cn/syntax/flowchart.html#cross-edge-example">cross
edge</a>。</p>
</blockquote>
<h4 id="语法">语法</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:+空格+标题</span><br><span class="line">---</span><br><span class="line">graph 方向     //graph也可以用flowchart</span><br><span class="line">	内容</span><br></pre></td></tr></table></figure>
<p><strong><mark>示例:</mark></strong></p>
<pre class="mermaid">---
title: Node
---
graph LR
    id</pre>
<blockquote>
<p>id是框中显示的内容</p>
<p>也可以给框其别名:名字+(内容) //括住内容的括号框的形状</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Node with text</span><br><span class="line">---</span><br><span class="line">flowchart LR</span><br><span class="line">    id1[This is the text in the box]</span><br><span class="line">    id1--&gt;A       //后面再次调用这个文本框直接用别名即可</span><br></pre></td></tr></table></figure>
<pre class="mermaid">---
title: Node with text
---
flowchart LR
    id1[This is the text in the box]
    id1-->A</pre>
<ul>
<li><strong>统一码文本</strong></li>
</ul>
<p>​ 使用 <code>""</code> 将 $unicode $文本括起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    id[&quot;This ❤ Unicode&quot;]   //在不同Markdown中表示的可能不一样,Typora不加引号爱心也可以正常显示</span><br></pre></td></tr></table></figure>
<pre class="mermaid">flowchart LR
    id["This ❤ Unicode"]</pre>
<ul>
<li><p><strong>在一个文本框显示多行</strong></p>
<p>直接在括号内部换行操作即可</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    markdown[&quot;`This **is** _Markdown_`&quot;]</span><br><span class="line">    newLines[&quot;`Line1</span><br><span class="line">    Line 2</span><br><span class="line">    Line 3`&quot;]</span><br><span class="line">    markdown --&gt; newLines</span><br></pre></td></tr></table></figure></p>
<pre class="mermaid">   flowchart LR
      markdown["`This **is** _Markdown_`"]
      newLines["`Line1
      Line 2
      Line 3`"]
      markdown --> newLines</pre></li>
<li><p><strong>方向</strong></p>
<p>在<span
class="math inline">\(graph或flowchart\)</span>后面接方向大写缩写</p>
<table>
<thead>
<tr>
<th style="text-align: left;">用词</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">TB/TD</td>
<td style="text-align: left;">从上到下</td>
</tr>
<tr>
<td style="text-align: left;">BT</td>
<td style="text-align: left;">从下到上</td>
</tr>
<tr>
<td style="text-align: left;">RL</td>
<td style="text-align: left;">从右到左</td>
</tr>
<tr>
<td style="text-align: left;">LR</td>
<td style="text-align: left;">从左到右</td>
</tr>
</tbody>
</table>
<blockquote>
<p>[!tip]</p>
<p>T = TOP，B = BOTTOM，L = LEFT，R = RIGHT，D = DOWN</p>
</blockquote>
<p>最常用的布局方向是TB、LR</p></li>
<li><p><strong>节点形状</strong></p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 18%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">表述</th>
<th style="text-align: left;">说明</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">id[文字]</td>
<td style="text-align: left;">矩形节点</td>
<td>表示过程，也就是整个流程中的一个环节</td>
</tr>
<tr>
<td style="text-align: left;">id(文字)</td>
<td style="text-align: left;">圆角矩形节点</td>
<td>表示开始和结束</td>
</tr>
<tr>
<td style="text-align: left;">id((文字))</td>
<td style="text-align: left;">圆形节点</td>
<td>表示连接。为避免流程过长或有交叉，可将流程切开。成对</td>
</tr>
<tr>
<td style="text-align: left;">id{文字}</td>
<td style="text-align: left;">菱形节点</td>
<td>表示判断、决策</td>
</tr>
<tr>
<td style="text-align: left;">id&gt;文字]</td>
<td style="text-align: left;">右向旗帜状节点</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>id即为节点的唯一标识(别名)，A~F
是当前节点名字，类似于变量名，画图时便于引用</p>
<p>括号内是节点中要显示的文字，默认节点的名字和显示的文字都为A</p>
</blockquote></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">  A</span><br><span class="line">  B(圆角矩形节点)</span><br><span class="line">  C[矩形节点]</span><br><span class="line">  D((圆形节点))</span><br><span class="line">  E&#123;菱形节点&#125;</span><br><span class="line">  F&gt;右向旗帜状节点] </span><br><span class="line">  G[(圆柱)]</span><br><span class="line">  H([圆弧节点])</span><br><span class="line">  I[[子程序节点]]</span><br><span class="line">  J&#123;&#123;六边形节点&#125;&#125;</span><br><span class="line">  K[/平行四边形/]</span><br><span class="line">  L[/梯形\]</span><br><span class="line">  M(((双圆)))</span><br></pre></td></tr></table></figure>
<pre class="mermaid">graph TB
  A
  B(圆角矩形节点)
  C[矩形节点]
  D((圆形节点))
  E{菱形节点}
  F>右向旗帜状节点]</pre>
<pre class="mermaid">graph TB  
  G[(圆柱)]
  H([圆弧节点])
  I[[子程序节点]]
  J
  K[/平行四边形/]
  L[/梯形\]
  M(((双圆)))</pre>
<ul>
<li><p><strong>连线</strong></p>
<p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">  A1--&gt;B1</span><br><span class="line">  A2---B2</span><br><span class="line">  A3--text---B3 //或者A---|text|B,连线符号结束的时候插入|text|即可:A-.-|test|B等等</span><br><span class="line">  A4--text--&gt;B4</span><br><span class="line">  A5-.-B5</span><br><span class="line">  A6-.-&gt;B6</span><br><span class="line">  A7-.text.-B7</span><br><span class="line">  A8-.text.-&gt;B8</span><br><span class="line">  A9===B9</span><br><span class="line">  A10==&gt;B10</span><br><span class="line">  A11==text===B11</span><br><span class="line">  A12==text==&gt;B12</span><br></pre></td></tr></table></figure></p>
<pre class="mermaid">   graph TB
    A1-->B1
    A2---B2
    A3--text---B3
    A4--text-->B4
    A5-.-B5
    A6-.->B6
    A7-.text.-B7
    A8-.text.->B8
    A9===B9
    A10==>B10
    A11==text===B11
    A12==text==>B12</pre></li>
<li><p><strong>多节点链接</strong></p>
<p>可以在同一行中声明多个链接，如下所示：</p>
<pre class="mermaid">   flowchart LR
     A -- text --> B -- text2 --> C</pre>
<p>还可以在同一行中声明多个节点链接，如下所示：<strong>用&amp;代表逻辑的与关系(<mark>注意&amp;前后要加空格</mark>)</strong></p>
<pre class="mermaid">   flowchart LR
     a --> b & c--> d</pre></li>
<li><p><strong>新的连线类型</strong></p>
<ul>
<li><p>圆边</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A --o B</span><br></pre></td></tr></table></figure></p>
<pre class="mermaid">       flowchart LR
      A --o B</pre></li>
<li><p>交叉边缘</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A --x B</span><br></pre></td></tr></table></figure></p>
<pre class="mermaid">       flowchart LR
      A --x B</pre></li>
</ul></li>
<li><p><strong>多方向箭头</strong></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A o--o B</span><br><span class="line">    B &lt;--&gt; C</span><br><span class="line">    C x--x D</span><br></pre></td></tr></table></figure></p>
<pre class="mermaid">   flowchart LR
      A o--o B
      B <--> C
      C x--x D</pre></li>
<li><p><strong>子图表</strong></p>
<p>使用以下语法添加子图表</p>
<p>设置了子图的名字后还可以指向整个子图</p>
<p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">subgraph 别名[子图表名称]</span><br><span class="line"><span class="code">    子图表中的描述语句...</span></span><br><span class="line"><span class="code">end</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"><span class="code">	  subgraph 买炸鸡前</span></span><br><span class="line"><span class="code">   			 begin(出门)--&gt; buy[出门买炸鸡]</span></span><br><span class="line"><span class="code">    end</span></span><br><span class="line"><span class="code">    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;</span></span><br><span class="line"><span class="code">    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)</span></span><br><span class="line"><span class="code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</span></span><br></pre></td></tr></table></figure></p>
<pre class="mermaid">   graph LR
        subgraph 买炸鸡前
               begin(出门)--> buy[出门买炸鸡]
      end
      buy --> IsRemaining{"还有没有炸鸡？"}
      IsRemaining --没有--> sad["伤心"]--> goBack(回家)
      IsRemaining -->|有|happy[买完炸鸡开心]--> goBack</pre></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    c1--&gt;a2</span><br><span class="line">    subgraph one</span><br><span class="line">    a1--&gt;a2</span><br><span class="line">    end</span><br><span class="line">    subgraph two</span><br><span class="line">    b1--&gt;b2</span><br><span class="line">    end</span><br><span class="line">    subgraph three</span><br><span class="line">    c1--&gt;c2</span><br><span class="line">    end</span><br><span class="line">    one --&gt; two</span><br><span class="line">    three --&gt; two</span><br><span class="line">    two --&gt; c2</span><br></pre></td></tr></table></figure>
<pre class="mermaid">flowchart LR
    c1-->a2
    subgraph one
    a1-->a2
    end
    subgraph two
    b1-->b2
    end
    subgraph three
    c1-->c2
    end
    one --> two
    three --> two
    two --> c2</pre>
<h2 id="表情符号">11.表情符号(●‘◡’●)</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">冒号+表情(EN)+冒号</span><br><span class="line">:smile:</span><br></pre></td></tr></table></figure>
<p>:happy:<span class="emoji" data-emoji="cry">😢</span><span
class="emoji" data-emoji="sun_with_face">🌞</span><span class="emoji"
data-emoji="smile">😄</span></p>
<p><a
href="https://gitee.com/hulu135289/Typora/blob/d609d5b94c18043abb92a2f9f56df53fe6f129c4/表情包.md">部分表情包点我:happy:</a></p>
<h2 id="数学公式">12.数学公式</h2>
<p><mark>兼容Latex公式</mark></p>
<ul>
<li><p><strong>局部数学公式:</strong>在两个$之间输入<span
class="math inline">\(LaTeX\)</span>代码</p></li>
<li><p><strong>公式块:</strong>输入两个$回车即可<kbd>ctrl</kbd>+<kbd>shift</kbd>+<kbd>M</kbd></p></li>
<li><p><label><input type="checkbox" checked="" />配合<span
class="math inline">\(SimpleTeX\)</span>截图转化为<span
class="math inline">\(LaTeX\)</span>公式在复制即可<span class="emoji"
data-emoji="white_flower">💮</span></label></p></li>
</ul>
<h2 id="支持html元素">13.支持HTML元素</h2>
<p><strong>MarkDown完全支持HTML语言</strong></p>
<ul>
<li><p>按键图案:<code>&lt;kbd&gt;Enter&lt;/kbd&gt;</code></p>
<p><kbd>Enter</kbd></p></li>
</ul>
<h2 id="目录生成">14.目录生成</h2>
<p>在生成目录的位置输入<code>[TOC]</code><mark>(注意要求<code>[TOC]</code>在行首)</mark>
<span class="math inline">\(TOC\)</span>是<span
class="math inline">\(Table\ of\ Contents\)</span>缩写</p>
<figure>
<img data-src="/images/Typora-Notes/20250331231609_002.gif" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>这是说明<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>技术教程</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>技术笔记</tag>
        <tag>Typora</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP工具指南</title>
    <url>/2025/03/31/MCP-Tools/</url>
    <content><![CDATA[<h1 id="mcp工具指南">MCP工具指南</h1>
<h2 id="什么是mcp">什么是MCP？</h2>
<p>MCP（Model Context
Protocol）是一个开源标准，用于连接AI助手与数据所在的系统，包括内容存储库、业务工具和开发环境。它的目标是帮助前沿模型产生更好、更相关的响应。</p>
<p>MCP采用客户端-主机-服务器架构，使AI应用程序能够与各种数据源和工具无缝连接：</p>
<ul>
<li><strong>MCP主机</strong>：使用MCP与各种资源交互的应用程序，如Claude
Desktop、开发环境或AI工具。</li>
<li><strong>MCP客户端</strong>：主机中与特定服务器建立直接一对一连接的组件。</li>
<li><strong>MCP服务器</strong>：设计用于通过MCP框架提供特定功能的小型程序。</li>
<li><strong>本地资源</strong>：计算机上的资源，如文件、数据库或服务，MCP服务器可以安全地检索和管理。</li>
<li><strong>远程资源</strong>：MCP服务器可以连接以获取数据或功能的外部在线资源，如API或基于云的服务。</li>
</ul>
<h2 id="可用的mcp工具列表">可用的MCP工具列表</h2>
<p>以下是当前可用的MCP工具及其功能和配置方法：</p>
<h3 id="文件系统工具-mcp_filesystem">1. 文件系统工具
(mcp_filesystem)</h3>
<p>这组工具允许AI助手与文件系统交互，执行文件和目录操作。</p>
<h4 id="可用功能">可用功能：</h4>
<table style="width:100%;">
<colgroup>
<col style="width: 42%" />
<col style="width: 28%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr>
<th>工具名称</th>
<th>描述</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mcp_filesystem_read_file</code></td>
<td>从文件系统读取文件的完整内容。处理各种文本编码并在无法读取文件时提供详细的错误消息。</td>
<td><code>path</code>: 文件路径（字符串）</td>
</tr>
<tr>
<td><code>mcp_filesystem_read_multiple_files</code></td>
<td>同时读取多个文件的内容。当需要分析或比较多个文件时，这比一个一个读取文件更有效率。</td>
<td><code>paths</code>: 文件路径数组（字符串数组）</td>
</tr>
<tr>
<td><code>mcp_filesystem_write_file</code></td>
<td>创建新文件或完全覆盖现有文件的内容。谨慎使用，因为它会覆盖现有文件而不发出警告。</td>
<td><code>path</code>: 文件路径（字符串）<br><code>content</code>:
文件内容（字符串）</td>
</tr>
<tr>
<td><code>mcp_filesystem_edit_file</code></td>
<td>对文本文件进行基于行的编辑。每次编辑都会用新内容替换精确的行序列。返回显示所做更改的git风格差异。</td>
<td><code>path</code>: 文件路径（字符串）<br><code>edits</code>:
编辑数组<br><code>dryRun</code>:
是否预览更改（布尔值，默认为false）</td>
</tr>
<tr>
<td><code>mcp_filesystem_create_directory</code></td>
<td>创建新目录或确保目录存在。可以在一次操作中创建多个嵌套目录。</td>
<td><code>path</code>: 目录路径（字符串）</td>
</tr>
<tr>
<td><code>mcp_filesystem_list_directory</code></td>
<td>获取指定路径中所有文件和目录的详细列表。结果清楚地区分文件和目录，分别带有[FILE]和[DIR]前缀。</td>
<td><code>path</code>: 目录路径（字符串）</td>
</tr>
<tr>
<td><code>mcp_filesystem_directory_tree</code></td>
<td>获取文件和目录的递归树视图作为JSON结构。每个条目包括”name”、“type”（文件/目录）和目录的”children”。</td>
<td><code>path</code>: 目录路径（字符串）</td>
</tr>
<tr>
<td><code>mcp_filesystem_move_file</code></td>
<td>移动或重命名文件和目录。可以在单个操作中移动文件并重命名它们。</td>
<td><code>source</code>: 源路径（字符串）<br><code>destination</code>:
目标路径（字符串）</td>
</tr>
<tr>
<td><code>mcp_filesystem_search_files</code></td>
<td>递归搜索匹配模式的文件和目录。从起始路径搜索所有子目录。搜索不区分大小写并匹配部分名称。</td>
<td><code>path</code>: 起始路径（字符串）<br><code>pattern</code>:
搜索模式（字符串）<br><code>excludePatterns</code>:
排除模式数组（可选）</td>
</tr>
<tr>
<td><code>mcp_filesystem_get_file_info</code></td>
<td>检索有关文件或目录的详细元数据。返回包括大小、创建时间、最后修改时间、权限和类型在内的综合信息。</td>
<td><code>path</code>: 文件或目录路径（字符串）</td>
</tr>
<tr>
<td><code>mcp_filesystem_list_allowed_directories</code></td>
<td>返回此服务器允许访问的目录列表。在尝试访问文件之前使用此功能了解哪些目录可用。</td>
<td><code>random_string</code>: 虚拟参数</td>
</tr>
</tbody>
</table>
<h4 id="配置方法">配置方法：</h4>
<p><strong>NPX方式：</strong> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;filesystem&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-y&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;@modelcontextprotocol/server-filesystem&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;/Users/username/Desktop&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;/path/to/other/allowed/dir&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Docker方式：</strong> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;filesystem&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;docker&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;run&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-i&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;--rm&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;--mount&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;type=bind,src=/Users/username/Desktop,dst=/projects/Desktop&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;--mount&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;type=bind,src=/path/to/other/allowed/dir,dst=/projects/other/allowed/dir,ro&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;--mount&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;type=bind,src=/path/to/file.txt,dst=/projects/path/to/file.txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;mcp/filesystem&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;/projects&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="网络抓取工具-mcp_fetch">2. 网络抓取工具 (mcp_fetch)</h3>
<p>这个工具允许AI助手从互联网获取信息。</p>
<h4 id="可用功能-1">可用功能：</h4>
<table style="width:100%;">
<colgroup>
<col style="width: 42%" />
<col style="width: 28%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr>
<th>工具名称</th>
<th>描述</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mcp_fetch_fetch</code></td>
<td>从互联网获取URL并可选择将其内容提取为markdown。</td>
<td><code>url</code>: 要获取的URL（字符串）<br><code>max_length</code>:
返回的最大字符数（整数，默认5000）<br><code>raw</code>:
是否获取实际HTML内容（布尔值，默认false）<br><code>start_index</code>:
从此字符索引开始返回输出（整数，默认0）</td>
</tr>
</tbody>
</table>
<h3 id="网页自动化工具-mcp_playwright">3. 网页自动化工具
(mcp_playwright)</h3>
<p>这组工具允许AI助手自动化网页交互，如导航、点击、填写表单等。</p>
<h4 id="可用功能-2">可用功能：</h4>
<table style="width:100%;">
<colgroup>
<col style="width: 42%" />
<col style="width: 28%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr>
<th>工具名称</th>
<th>描述</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mcp_playwright_playwright_navigate</code></td>
<td>导航到URL</td>
<td><code>url</code>: 要导航到的URL（字符串）<br><code>width</code>:
视口宽度（数字，默认1280）<br><code>height</code>:
视口高度（数字，默认720）<br><code>timeout</code>:
导航超时（毫秒）<br><code>waitUntil</code>: 导航等待条件</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_screenshot</code></td>
<td>截取当前页面或特定元素的屏幕截图</td>
<td><code>name</code>: 截图名称（字符串）<br><code>selector</code>:
要截图的元素的CSS选择器（可选）<br><code>fullPage</code>:
是否存储整个页面的截图（布尔值，默认false）<br><code>width</code>:
宽度（像素，默认800）<br><code>height</code>:
高度（像素，默认600）<br><code>savePng</code>:
是否将截图保存为PNG文件（布尔值，默认false）<br><code>storeBase64</code>:
是否以base64格式存储截图（布尔值，默认true）<br><code>downloadsDir</code>:
自定义下载目录路径</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_click</code></td>
<td>点击页面上的元素</td>
<td><code>selector</code>: 要点击的元素的CSS选择器（字符串）</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_iframe_click</code></td>
<td>点击页面上iframe中的元素</td>
<td><code>iframeSelector</code>:
包含要点击元素的iframe的CSS选择器（字符串）<br><code>selector</code>:
要点击的元素的CSS选择器（字符串）</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_fill</code></td>
<td>填写输入字段</td>
<td><code>selector</code>:
输入字段的CSS选择器（字符串）<br><code>value</code>:
要填写的值（字符串）</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_select</code></td>
<td>选择页面上带有Select标签的元素</td>
<td><code>selector</code>:
要选择的元素的CSS选择器（字符串）<br><code>value</code>:
要选择的值（字符串）</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_hover</code></td>
<td>悬停在页面上的元素上</td>
<td><code>selector</code>: 要悬停的元素的CSS选择器（字符串）</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_evaluate</code></td>
<td>在浏览器控制台中执行JavaScript</td>
<td><code>script</code>: 要执行的JavaScript代码（字符串）</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_console_logs</code></td>
<td>从浏览器检索控制台日志，带有过滤选项</td>
<td><code>type</code>: 要检索的日志类型（all, error, warning, log, info,
debug）<br><code>search</code>:
在日志中搜索的文本<br><code>limit</code>:
要返回的最大日志数<br><code>clear</code>:
是否在检索后清除日志（布尔值，默认false）</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_close</code></td>
<td>关闭浏览器并释放所有资源</td>
<td><code>random_string</code>: 虚拟参数</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_get</code></td>
<td>执行HTTP GET请求</td>
<td><code>url</code>: 要执行GET操作的URL（字符串）</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_post</code></td>
<td>执行HTTP POST请求</td>
<td><code>url</code>:
要执行POST操作的URL（字符串）<br><code>value</code>:
要在正文中发布的数据（字符串）</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_put</code></td>
<td>执行HTTP PUT请求</td>
<td><code>url</code>:
要执行PUT操作的URL（字符串）<br><code>value</code>:
要在正文中PUT的数据（字符串）</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_patch</code></td>
<td>执行HTTP PATCH请求</td>
<td><code>url</code>:
要执行PATCH操作的URL（字符串）<br><code>value</code>:
要在正文中PATCH的数据（字符串）</td>
</tr>
<tr>
<td><code>mcp_playwright_playwright_delete</code></td>
<td>执行HTTP DELETE请求</td>
<td><code>url</code>: 要执行DELETE操作的URL（字符串）</td>
</tr>
</tbody>
</table>
<h4 id="配置方法-1">配置方法：</h4>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;puppeteer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-y&quot;</span><span class="punctuation">,</span> <span class="string">&quot;@modelcontextprotocol/server-puppeteer&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="顺序思考工具-mcp_sequential_thinking">4. 顺序思考工具
(mcp_sequential_thinking)</h3>
<p>这个工具帮助AI助手通过灵活的思考过程进行动态和反思性的问题解决。</p>
<h4 id="可用功能-3">可用功能：</h4>
<table style="width:100%;">
<colgroup>
<col style="width: 42%" />
<col style="width: 28%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr>
<th>工具名称</th>
<th>描述</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mcp_sequential_thinking_sequentialthinking</code></td>
<td>通过思想进行详细的动态和反思性问题解决的工具。这个工具通过可以适应和发展的灵活思考过程帮助分析问题。每个思想可以在理解深入时建立在前面的见解上，质疑或修改它们。</td>
<td><code>thought</code>:
当前思考步骤（字符串）<br><code>nextThoughtNeeded</code>:
是否需要另一个思考步骤（布尔值）<br><code>thoughtNumber</code>:
当前思考编号（整数，最小值1）<br><code>totalThoughts</code>:
估计需要的总思考数（整数，最小值1）<br><code>isRevision</code>:
这是否修改了之前的思考（布尔值，可选）<br><code>revisesThought</code>:
正在重新考虑哪个思考（整数，最小值1，可选）<br><code>branchFromThought</code>:
分支点思考编号（整数，最小值1，可选）<br><code>branchId</code>:
分支标识符（字符串，可选）<br><code>needsMoreThoughts</code>:
是否需要更多思考（布尔值，可选）</td>
</tr>
</tbody>
</table>
<h4 id="使用场景">使用场景：</h4>
<ul>
<li>分解复杂问题为步骤</li>
<li>需要修改空间的规划和设计</li>
<li>可能需要修正的分析</li>
<li>初始范围不明确的问题</li>
<li>需要在多个步骤中保持上下文的任务</li>
<li>需要过滤无关信息的情况</li>
</ul>
<h4 id="配置方法-2">配置方法：</h4>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sequential-thinking&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-y&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;@modelcontextprotocol/server-sequential-thinking&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="官方mcp服务器">5. 官方MCP服务器</h3>
<p>以下是Anthropic官方提供的MCP服务器及其配置方法：</p>
<h4
id="brave搜索mcp工具-modelcontextprotocolserver-brave-search">Brave搜索MCP工具
(<span class="citation"
data-cites="modelcontextprotocol/server-brave-search">@modelcontextprotocol/server-brave-search</span>)</h4>
<p>允许Claude Desktop应用程序在网络上搜索。</p>
<p><strong>功能：</strong></p>
<ul>
<li><strong>brave_web_search</strong>：执行网络搜索，支持分页和过滤
<ul>
<li>参数：
<ul>
<li><code>query</code></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>技术教程</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>MCP</tag>
        <tag>开发工具</tag>
        <tag>AI工具</tag>
        <tag>Claude</tag>
      </tags>
  </entry>
  <entry>
    <title>Configure a C/C++ development environment for VScode</title>
    <url>/2025/04/01/VScode-C-Cpp/</url>
    <content><![CDATA[<h1 id="VSCode配置C语言开发环境"><a href="#VSCode配置C语言开发环境" class="headerlink" title="VSCode配置C语言开发环境"></a>VSCode配置C语言开发环境</h1><h2 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h2><h3 id="下载Visual-Studio-Code"><a href="#下载Visual-Studio-Code" class="headerlink" title="下载Visual Studio Code"></a>下载Visual Studio Code</h3><p>进入官网下载<a href="https://code.visualstudio.com/">官网地址</a></p>
<h4 id="下载C-C-插件"><a href="#下载C-C-插件" class="headerlink" title="下载C&#x2F;C++插件"></a>下载C&#x2F;C++插件</h4><p>只建议下载以下(小项目可以直接用插件带的运行或者终端手动调整参数,大项目用CMake构建,不推荐使用Code_Runner)</p>
<p><img data-src="/images/VScode-C-Cpp/20250402000218_001.png" alt="image-20250401225734475"></p>
<h3 id="下载C-C-编译工具"><a href="#下载C-C-编译工具" class="headerlink" title="下载C&#x2F;C++编译工具"></a>下载C&#x2F;C++编译工具</h3><p>到官网下载合适系统的MINGW编译工具链 <a href="https://www.mingw-w64.org/">MinGW官网</a></p>
<p><a href="https://sourceforge.net/projects/mingw/files/">MinGW</a></p>
<h4 id="配置编译工具环境变量"><a href="#配置编译工具环境变量" class="headerlink" title="配置编译工具环境变量"></a>配置编译工具环境变量</h4><p>将MinGW的bin目录添加到系统环境变量PATH中：</p>
<ul>
<li>搜索并打开”编辑系统环境变量”</li>
<li>点击”环境变量”</li>
<li>在”用户变量”区域找到PATH变量并编辑</li>
<li>添加新路径：<code>\path\bin</code>（请调整路径）</li>
<li>点击”确定”保存设置</li>
</ul>
<p> <strong>&#x3D;&#x3D;验证安装：打开命令提示符（CMD）并输入以下命令检查是否安装成功：&#x3D;&#x3D;</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br><span class="line">g++ --version</span><br><span class="line">gdb --version</span><br></pre></td></tr></table></figure>



<p>完成以上操作后就可以正式开始搭建编程环境</p>
<p>打开一个文件夹,新建一个源文件编译,选择编译器gcc,会生成一个.vscode目录和task.json文件<br><img data-src="/images/VScode-C-Cpp/20250402000219_002.png" alt="image-20250401231051819"></p>
<p>然后可以在生成的.vscode目录细化配置,我的配置如下,由于Windows系统兼容性问题,对C语言long double类型数据兼容有问题,在args添加<code>&quot;-D__USE_MINGW_ANSI_STDIO=1&quot;</code>即可解决这个问题<br>然后<code>&quot;$&#123;fileDirname&#125;\\*.c&quot;</code>编译的目录改为当前文件目录的所有.c文件,方便编译小项目文件,<br><code>&quot;$&#123;fileDirname&#125;\\output\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</code>把可执行文件在当前目录的output目录生成(自动生成output目录)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\BianYiQi\\mingw64\\bin\\gcc.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-D__USE_MINGW_ANSI_STDIO=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\*.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\output\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-lpowrprof&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: clang.exe build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\BianYiQi\\mingw64\\bin\\clang.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fcolor-diagnostics&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-fansi-escape-codes&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\*.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\output\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-lpowrprof&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Task generated by Debugger.&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;presentation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;echo&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;reveal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;always&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;focus&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;panel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shared&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;showReuseMessage&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;clear&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>打断点就可以调试了,自定义调试可以<img data-src="/images/VScode-C-Cpp/20250402000221_003.png" alt="image-20250401231833484"></p>
<p>选择<code>create a launch.json file</code>,选择GDB</p>
<p><img data-src="/images/VScode-C-Cpp/20250402000222_004.png" alt="image-20250401231951295"></p>
<p><img data-src="/images/VScode-C-Cpp/20250402000223_005.png" alt="image-20250401232023543"></p>
<p>选择<code>Attach</code>得到</p>
<p><img data-src="/images/VScode-C-Cpp/20250402000226_006.png" alt="image-20250401232115546"></p>
<p>需要修改<code>program</code>为<code>task.json</code>可执行文件生成路径如果没有改动可执行文件路径就可以填这个</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">$<span class="punctuation">&#123;</span>fileDirname<span class="punctuation">&#125;</span>\\$<span class="punctuation">&#123;</span>fileBasenameNoExtension<span class="punctuation">&#125;</span>.exe</span><br></pre></td></tr></table></figure>

<p>把<code>miDebuggerPath</code>改为gdb调试器的路径,可以在<code>\path\bin</code>找到</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\output\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\BianYiQi\\mingw64\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: clang.exe build and debug active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\output\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\BianYiQi\\mingw64\\bin\\lldb.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Set Disassembly Flavor to Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: clang.exe build active file&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>然后以下是一些其他的配置,会生成<code>c_cpp_properties.json</code>文件</p>
<p><code>ctrl+shift+P</code>输入C&#x2F;C++选择这个<br><img data-src="/images/VScode-C-Cpp/20250402000228_007.png" alt="image-20250401230521055"></p>
<p>然后填写相关的内容<br><img data-src="/images/VScode-C-Cpp/20250402000229_008.png" alt="屏幕截图 2025-04-01 230551"></p>
<p><img data-src="/images/VScode-C-Cpp/20250402000232_009.png" alt="屏幕截图 2025-04-01 230604"></p>
<p>根据实际情况填写</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;windowsSdkVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.22621.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\BianYiQi\\mingw64\\bin\\gcc.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerArgs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;windowsSdkVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.22621.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\BianYiQi\\mingw64\\bin\\g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>至此Windows系统环境就配置好了,比Linux系统麻烦一点</p>
<h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><p>由于Ubuntu的配置有点问题,找了很多方法都没有解决调试找不到系统库的问题,所以只以CentOS为例</p>
<h3 id="下载code"><a href="#下载code" class="headerlink" title="下载code"></a>下载code</h3><p>官网下载安装即可</p>
<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>CentOS自带编译工具,无需额外下载</p>
<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>打开一个目录,新建源文件运行,选择相应的编译器即可,然后调试方面创建Launch.json文件安装Windows系统类似配置即可,不过Linux系统下即使有GUI还是感觉终端编译方便一点,还可以自己加参数,见Compiler文章介绍gcc编译一些基础参数</p>
<h2 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h2><h3 id="配置多文件项目"><a href="#配置多文件项目" class="headerlink" title="配置多文件项目"></a>配置多文件项目</h3><p>对于包含多个源文件的项目，可以修改<code>tasks.json</code>中的<code>args</code>数组，添加所有需要编译的源文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;workspaceFolder&#125;\\*.c&quot;</span><span class="punctuation">,</span>  <span class="comment">// 编译所有.c文件,上面$&#123;fileDirname&#125;\\*.c编译当前目录下所有.c文件,这里是当前工作区,很大不同</span></span><br><span class="line">    <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;workspaceFolder&#125;\\main.exe&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h3 id="添加头文件目录"><a href="#添加头文件目录" class="headerlink" title="添加头文件目录"></a>添加头文件目录</h3><p>如果项目包含自定义头文件目录，可以在<code>args</code>数组中添加<code>-I</code>参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-I$&#123;workspaceFolder&#125;\\include&quot;</span><span class="punctuation">,</span>  <span class="comment">// 添加头文件目录</span></span><br><span class="line">    <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h3 id="链接外部库"><a href="#链接外部库" class="headerlink" title="链接外部库"></a>链接外部库</h3><p>如果需要链接外部库，可以在<code>args</code>数组中添加<code>-l</code>参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-lm&quot;</span>  <span class="comment">// 链接数学库</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h2 id="常见问题及其解决方法"><a href="#常见问题及其解决方法" class="headerlink" title="常见问题及其解决方法"></a>常见问题及其解决方法</h2><h3 id="1-找不到编译器或调试器"><a href="#1-找不到编译器或调试器" class="headerlink" title="1. 找不到编译器或调试器"></a>1. 找不到编译器或调试器</h3><p>确保MinGW的bin目录已正确添加到系统PATH环境变量中，并检查<code>tasks.json</code>和<code>launch.json</code>中的路径是否正确。</p>
<h3 id="2-调试时出现”找不到任务”错误"><a href="#2-调试时出现”找不到任务”错误" class="headerlink" title="2. 调试时出现”找不到任务”错误"></a>2. 调试时出现”找不到任务”错误</h3><p>确保<code>launch.json</code>中的<code>preLaunchTask</code>字段值与<code>tasks.json</code>中的<code>label</code>字段值完全一致。</p>
<h3 id="3-调试时出现”程序不存在”错误"><a href="#3-调试时出现”程序不存在”错误" class="headerlink" title="3. 调试时出现”程序不存在”错误"></a>3. 调试时出现”程序不存在”错误</h3><p>确保<code>launch.json</code>中的<code>program</code>字段路径与<code>tasks.json</code>中<code>args</code>数组中的<code>-o</code>参数指定的输出文件路径一致。</p>
<h3 id="4-调试器错误："><a href="#4-调试器错误：" class="headerlink" title="4. 调试器错误："></a>4. 调试器错误：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;unrecognized command line option &#x27;--interpreter=mi&#x27;&quot;</span><br></pre></td></tr></table></figure>



<p>这通常是因为在<code>launch.json</code>中错误地将编译器（gcc.exe）指定为调试器。确保<code>miDebuggerPath</code>指向的是调试器（gdb.exe）而不是编译器。</p>
<p><a href="https://code.visualstudio.com/docs">参考</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>技术笔记</tag>
        <tag>环境配置</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>文件查找工具-Everything配置</title>
    <url>/2025/04/05/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%B7%A5%E5%85%B7-Everything%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<h2 id="everything文件搜索工具概述">1. Everything文件搜索工具概述</h2>
<h3 id="everything简介">1.1 Everything简介</h3>
<p>Everything是一款高效的桌面文件搜索工具，特别适合在文件数量庞大的系统中快速定位文件。它通过建立索引的方式，将硬盘中所有的文件名信息收纳其中，用户可通过简单快捷的关键词查询，迅速找到所需的文件。</p>
<h3 id="everything的特点">1.2 Everything的特点</h3>
<p>Everything的特点在于其轻量级和高速度。它占用的系统资源少，搜索速度快，且对中文搜索支持良好。在本章中，我们将详细了解Everything的基本使用方法，为后续章节的深入探讨打下基础。</p>
<h2 id="everything的文件搜索特性与实现">2.
Everything的文件搜索特性与实现</h2>
<h3 id="everything的搜索核心">2.1 Everything的搜索核心</h3>
<h4 id="索引构建原理">2.1.1 索引构建原理</h4>
<p>Everything的搜索效率之所以卓越，在于其使用了文件系统监视器（File
System
Monitor）来监控文件系统的实时变化，并且采用了非常高效的索引构建机制。在Everything启动时，程序会遍历NTFS分区上的Master
File Table
(MFT)，然后创建一个索引数据库。这个数据库包含了文件名、大小、创建时间、文件类型等基本信息。文件名是搜索的关键属性，因为它直接关联到用户的查询。</p>
<p>使用MFT的索引不仅能够快速访问文件信息，而且在搜索时可以实现真正的即时结果更新。索引数据库每次启动时会重建，但更新操作非常迅速，用户几乎感觉不到延迟。</p>
<h1 id="配置">配置</h1>
<h2 id="常规">1、常规</h2>
<figure>
<img data-src="/images/文件查找工具-Everything配置/20250405171121_001.png"
alt="Everything软件常规设置界面，显示了基本配置选项" />
<figcaption
aria-hidden="true">Everything软件常规设置界面，显示了基本配置选项</figcaption>
</figure>
<p>这里建议配置以下选项： - 开机启动：勾选”开机时自动启动Everything” -
数据库位置：默认即可，或选择固态硬盘上的位置以提高性能 -
索引选项：勾选”监视文件系统变化”以实时更新索引 -
索引驱动器：建议只选择常用的本地驱动器，排除网络驱动器和可移动设备</p>
<h2 id="界面">2、界面</h2>
<figure>
<img data-src="/images/文件查找工具-Everything配置/20250405171122_002.png"
alt="Everything软件界面设置页面，展示了显示选项和用户界面偏好设置" />
<figcaption
aria-hidden="true">Everything软件界面设置页面，展示了显示选项和用户界面偏好设置</figcaption>
</figure>
<p>界面配置推荐： - 语言：选择”中文(简体)” -
窗口位置：勾选”记住主窗口位置和大小” - 双击动作：选择”打开文件” -
右键菜单：勾选”启用右键菜单”和”包含Windows资源管理器右键菜单项” -
系统托盘图标：勾选”总是显示系统托盘图标”</p>
<h2 id="搜索结果">3、搜索结果</h2>
<figure>
<img data-src="/images/文件查找工具-Everything配置/20250405171123_003.jpeg"
alt="Everything软件搜索结果设置页面，显示了结果排序和显示相关选项" />
<figcaption
aria-hidden="true">Everything软件搜索结果设置页面，显示了结果排序和显示相关选项</figcaption>
</figure>
<p>搜索结果设置建议： - 排序：默认按”名称”排序 -
列表视图：勾选”名称”、“路径”、“大小”、“修改日期”列 -
结果限制：可设置为10000以提高性能 -
匹配整个词：根据个人习惯选择，建议不勾选以获得更灵活的搜索结果</p>
<h2 id="搜索列表重要修改">4、搜索列表（重要修改）</h2>
<p>启用高亮 关键字的颜色 和 行的颜色 。</p>
<figure>
<img data-src="/images/文件查找工具-Everything配置/20250405171124_004.png"
alt="搜索列表设置界面，展示了高亮关键字和行颜色的配置选项" />
<figcaption
aria-hidden="true">搜索列表设置界面，展示了高亮关键字和行颜色的配置选项</figcaption>
</figure>
<h2
id="搜索列表关键字的字体与颜色重要修改">5、搜索列表关键字的字体与颜色（重要修改）</h2>
<p>主要是修改 搜索关键字的颜色。</p>
<h3
id="高亮部分对其前景色设置自定义为红色">1）<strong>高亮部分</strong>，对其<strong>前景色</strong>设置自定义为<strong>红色</strong></h3>
<p><strong>常规 –&gt;
字体与颜色</strong>的界面中，找到<strong>高亮部分</strong>，对其<strong>前景色</strong>设置
自定义为** 红色**。</p>
<figure>
<img data-src="/images/文件查找工具-Everything配置/20250405171125_005.png"
alt="高亮部分前景色设置为红色的效果展示，匹配的关键字用红色标记" />
<figcaption
aria-hidden="true">高亮部分前景色设置为红色的效果展示，匹配的关键字用红色标记</figcaption>
</figure>
<p>效果如上图所示，匹配的字符的颜色变为 自定义的红色。</p>
<h3
id="鼠标悬停对其背景色设置-自定义为浅蓝色">2）<strong>鼠标悬停</strong>，对其<strong>背景色</strong>设置
自定义为<strong>浅蓝色</strong></h3>
<p>设置当前行的背景色 工具 –&gt; 选项 –&gt; 字体与颜色 –&gt;项目状态
的界面中， 找到<strong>鼠标悬停</strong>，对其
<strong>背景色</strong>设置 自定义为 <strong>浅蓝色</strong></p>
<figure>
<img data-src="/images/文件查找工具-Everything配置/20250405171126_006.png"
alt="鼠标悬停背景色设置界面，展示了背景色配置选项" />
<figcaption
aria-hidden="true">鼠标悬停背景色设置界面，展示了背景色配置选项</figcaption>
</figure>
<p><strong>自定义颜色：</strong> <img data-src="/images/文件查找工具-Everything配置/20250405171127_007.png"
alt="自定义颜色选择器界面，用于选择鼠标悬停时的背景颜色" /></p>
<h4 id="配置效果">3）配置效果</h4>
<p>鼠标经过时，前景色 为自定义的颜色。 <img data-src="/images/文件查找工具-Everything配置/20250405171128_008.png"
alt="鼠标悬停效果展示，显示当鼠标经过时项目的高亮效果" /></p>
<h2 id="搜索框放大">6、搜索框放大</h2>
<p>搜索并打开
<code>【用户】\AppData\Roaming\Everything\Everything.ini</code>
文件，</p>
<p><img data-src="/images/文件查找工具-Everything配置/20250405171129_009.png"
alt="Everything.ini配置文件的位置，显示了文件在资源管理器中的路径" />
<strong>先退出 Everything 进程，然后再编辑修改 Everything.ini</strong>
， 搜索 <code>search_edit_font_size</code> 参数，将其改为
<code>search_edit_font_size=16</code> ，</p>
<figure>
<img data-src="/images/文件查找工具-Everything配置/20250405171130_010.png"
alt="Everything.ini文件中的search_edit_font_size参数设置，将字体大小设为16" />
<figcaption
aria-hidden="true">Everything.ini文件中的search_edit_font_size参数设置，将字体大小设为16</figcaption>
</figure>
<p>启动 Everything 就可以看到
<strong>搜索框的字体被放大了（下图）</strong> 。</p>
<figure>
<img data-src="/images/文件查找工具-Everything配置/20250405164848815_011.png"
alt="搜索框字体放大后的效果展示，可以看到搜索栏的字体明显变大" />
<figcaption
aria-hidden="true">搜索框字体放大后的效果展示，可以看到搜索栏的字体明显变大</figcaption>
</figure>
<h2 id="时间格式">7、时间格式</h2>
<p>默认时间格式如下：</p>
<figure>
<img data-src="/images/文件查找工具-Everything配置/20250405171131_012.png"
alt="Everything默认时间格式展示，显示了文件的日期和时间格式" />
<figcaption
aria-hidden="true">Everything默认时间格式展示，显示了文件的日期和时间格式</figcaption>
</figure>
<p>与上一个配置操作一样，搜索并打开
<code>【用户】\AppData\Roaming\Everything\Everything.ini</code> 文件，
<strong>先退出 Everything 进程，然后再编辑修改 Everything.ini</strong>
，</p>
<p>在 <code>Everything.ini</code> 文件中，分别搜索
<code>date_format</code> 和 <code>time_format</code>
两个参数，将其值如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date_format=yyyy-MM-<span class="built_in">dd</span></span><br><span class="line">time_format=HH:mm:ss</span><br><span class="line">12AI写代码</span><br></pre></td></tr></table></figure>
<p>重启 Everything 就可以看到 列表中时间格式发生变化 。</p>
<figure>
<img data-src="/images/文件查找工具-Everything配置/20250405171132_013.png"
alt="修改后的时间格式效果展示，日期显示为年-月-日，时间显示为时:分:秒" />
<figcaption
aria-hidden="true">修改后的时间格式效果展示，日期显示为年-月-日，时间显示为时:分:秒</figcaption>
</figure>
<h2 id="开启历史">8、开启历史</h2>
<figure>
<img data-src="/images/文件查找工具-Everything配置/20250405171133_014.png"
alt="历史记录设置界面，展示了搜索历史的保存和显示选项" />
<figcaption
aria-hidden="true">历史记录设置界面，展示了搜索历史的保存和显示选项</figcaption>
</figure>
<p>历史记录配置建议： - 启用历史：勾选”启用搜索历史” -
历史条目数：设置为”50”条（根据个人需求可以调整） -
保存位置：默认保存在配置文件中 -
隐私选项：可勾选”退出时清除历史”以保护隐私</p>
<h2 id="启动排除功能">9、启动排除功能</h2>
<figure>
<img data-src="/images/文件查找工具-Everything配置/20250405171134_015.png"
alt="启动排除功能设置界面，显示了可以排除特定文件或目录的配置选项" />
<figcaption
aria-hidden="true">启动排除功能设置界面，显示了可以排除特定文件或目录的配置选项</figcaption>
</figure>
<p>排除功能配置建议： - 排除文件夹：建议排除临时文件夹、缓存文件夹 -
常见排除项： - C: - C: - 各种大型软件缓存目录 -
排除文件类型：可排除临时文件如<em>.tmp、</em>.temp -
排除NTFS文件：勾选”排除NTFS系统文件”以减少索引量</p>
<h2 id="快捷键设置">10、快捷键设置</h2>
<p>为提高工作效率，建议设置以下快捷键： -
激活窗口：Alt+Space（可唤起搜索窗口） -
搜索所有：Ctrl+Shift+Space（可快速搜索所有文件） -
搜索文件夹：Ctrl+Alt+F（仅搜索文件夹） -
高级搜索：Ctrl+Shift+F（打开高级搜索对话框）</p>
<h2 id="正则表达式搜索技巧">11、正则表达式搜索技巧</h2>
<p>Everything支持强大的正则表达式搜索，以下是常用技巧： -
搜索特定类型文件：<code>*.pdf</code>（所有PDF文件） -
搜索特定文件夹：<code>C:\Projects\*</code>（Projects文件夹下所有文件） -
排除词搜索：<code>project !backup</code>（包含project但不包含backup的文件）
- 使用通配符：<code>pro?ect</code>（匹配project、protest等） -
日期搜索：<code>modified:&gt;2025/04/05</code>（2025年4月5日后修改的文件）</p>
<p><a
href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F#%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5">正则表达式参考链接</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术分享</category>
        <category>软件推荐</category>
        <category>文件查找</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>技术笔记</tag>
        <tag>文件查找</tag>
        <tag>文件搜索</tag>
        <tag>文件查找工具</tag>
        <tag>Everything</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>C语言指针学习笔记</title>
    <url>/2025/05/29/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!-- 目录自动生成，通过页面配置toc:true实现 -->

<blockquote>
<p>指针是C语言的精髓，也是C语言相对其他高级语言的一大特色。正确理解和使用指针对于深入学习C语言至关重要。本文将从基本概念出发，详细介绍各种指针类型、指针操作以及常见应用场景，帮助读者全面掌握C语言指针。</p>
</blockquote>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针介绍"><a href="#指针介绍" class="headerlink" title="指针介绍"></a>指针介绍</h2><blockquote>
<p><strong>警告</strong></p>
<p>*号在不同地方意义不同</p>
<ul>
<li>*前面有类型:表示指针</li>
<li>*前面没有类型:表示解引用运算符</li>
</ul>
</blockquote>
<ul>
<li><p>通常的指针是指针变量的简称,是一个指向对象地址的变量指针以指向对象的类型不同分为很多种不同的指针,比如说指向int的一级指针,int**的二级指针$…$</p>
</li>
<li><p><strong>指针做加减元素,地址变化的值是:加减的整数乘上指针指向的数据类型占用字节大小</strong></p>
</li>
</ul>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p=&amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n%p\n&quot;</span>,p,p+<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针变化的值是$4*4&#x3D;16$</p>
<blockquote>
<p><strong>注意</strong></p>
<p>专门用%td表示两个相同类型的指针的差值(相同类型的意思是指向相同类型的数据,比如说都指向int,指向int*)</p>
</blockquote>
<ul>
<li><p>两个指针的比较</p>
<p>  使用关系运算符可以比较两个指针的值，前提是两个指针都指向使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象</p>
</li>
</ul>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_001.png" alt="image-20250315180903892"></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_002.png" alt="image-20250315214007621"></p>
<blockquote>
<p><strong>重要</strong> </p>
<p><strong>给函数形参加const防止改变数组元素:</strong></p>
</blockquote>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_003.png" alt="image-20250315220717732"></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_004.png" alt="image-20250315220731318"></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_005.png" alt="image-20250315220748555"></p>
<h3 id="步长-偏移量"><a href="#步长-偏移量" class="headerlink" title="步长(偏移量)"></a>步长(偏移量)</h3><p>步长取决于指针指向变量的类型</p>
<p>注意对指针加减都是以元素为单位计量的,比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> *ptr1=(arr+<span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> *ptr2=(arr+<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> len=ptr1-ptr2 ;<span class="comment">//得到的是2,而不是8</span></span><br></pre></td></tr></table></figure>



<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_006.png" alt="image-20250315235453620"></p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><blockquote>
<p><strong>提示</strong></p>
<p><strong>一条语句(语句以分号为结束)多个变量声明的时候,指针指向的类型和*分开,类型在最前面,*和变量连在一起</strong></p>
</blockquote>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_007.png" alt="image-20250316002120252"></p>
<h3 id="sizeof-与strlen比较"><a href="#sizeof-与strlen比较" class="headerlink" title="sizeof 与strlen比较"></a><code>sizeof</code> 与<code>strlen</code>比较</h3><p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_008.png" alt="image-20250521141852262"></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_009.png" alt="image-20250521141912736"></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_010.png" alt="image-20250521141923632"></p>
<p>⭐⭐⭐<strong>示例代码使用<code>sizeof</code>,主要理解数组名发生隐式转换(退化)为首元素地址的例外情况</strong></p>
<blockquote>
<p><strong>警告</strong></p>
<p>注意只有<code>sizeof+数组</code>和<code>&amp;+数组</code>数组名才不会隐式转换为首元素地址,<strong>要是放的不是数组名或者数组名等价表示(如<code>*&amp;arr</code>)均会隐式转换为地址</strong>,下面的函数名退化规则和数组 名退化规则完全一致,只不过函数名退化为函数入口地址,和<code>&amp;函数名</code>结果一样,省去很多麻烦,以后如果数组不是以上两种情况不隐式转换的时候,<strong>都需要使用首元素地址去分析问题</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(a));      <span class="comment">//16,sizeof(数组名)此时数组名不会隐式转换为地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(a + <span class="number">0</span>));	 <span class="comment">//⭐8,a+0转换为(多了+0导致的)首元素地址,然后再计算地址大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(*a));     <span class="comment">//4,一个int类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(a + <span class="number">1</span>));	 <span class="comment">//8,同上</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">1</span>]));	 <span class="comment">//4,int类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));	 <span class="comment">//8,&amp;+数组名数组不会隐式转换,此时&amp;a表示整个数组地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(*&amp;a));    <span class="comment">//⭐16,&amp;a整个数组地址,再解引用得到数组,sizeof(数组名)不退化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;*a));    <span class="comment">//⭐8,表示首元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a + <span class="number">1</span>)); <span class="comment">//8,一个地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]));  <span class="comment">//8一个地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>] + <span class="number">1</span>)); <span class="comment">//8,一个地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_011.png" alt="image-20250521155337472"></p>
<blockquote>
<p><strong>提示</strong></p>
<p>⭐⭐⭐使用<code>strlen</code>函数计算字符串长度传入的参数是<code>cosnt char*</code>类型,第三和第四的个传入<code>char</code>类型,<strong>会强转为指针类型,但是该地址不可访问导致段错误,倒数第二,三个也会强转,但是强转后还是指针,是可访问的</strong></p>
</blockquote>
<p><strong>练习</strong></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_012.png" alt="image-20250521160108256"></p>
<blockquote>
<p><strong>答案:</strong></p>
<ol>
<li>第3个<code>a[0]</code>代表第一行,<code>sizof</code>直接加数组不会隐式转换为首元素指针,所以是16</li>
<li>第4个<code>a[0]+1</code>,数组名退化为首元素指针,结果是4&#x2F;8</li>
<li>第5个<code>*(a[0]+1)</code>代表第二行,直接<code>sizeof</code>不会隐式转换为指针</li>
<li>第6个同上退化为指针,结果8</li>
<li>第7个代表第二行,而且直接在<code>sizeof</code>后面,结果16</li>
<li>第8个<code>sizeof(&amp;a[0]+1)</code>,对第一行取地址得到第一行地址,加一得到第二行地址,<code>sizeof</code>计算得8</li>
</ol>
<p><strong>关键分析出数组是否退化(隐式转换)为首元素指针,只有<code>&amp;+数组</code>和<code>sizeof+数组</code>才不会隐式转换,需要分清</strong></p>
</blockquote>
<h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><blockquote>
<p>前言<br>即使是const修饰变量,指针还是可以操作地址改变其值,因为const修饰作用是限制直接修改变量的值,从而有了const修饰指针</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=&amp;num; <span class="comment">//和int const *p等价,相当于int可以忽略,const直接修饰*p</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p=&amp;num;  <span class="comment">//const在p右边修饰p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象不同导致作用不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const int *p:修饰的是*p表示指针指向的是常变量,不能修改*p(注意*p不能修改而已,但是可以通过其他指针或者num本身修改num值)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int* const p:修饰的是指针p,表示p的值不能改变,即p只能指向&amp;num,p++非法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p=&amp;num; <span class="comment">//既修饰*p也修饰p,表示*p和p都不可以修改</span></span><br></pre></td></tr></table></figure>

<p>注:const修饰int *p的时候*理解为解引用表示const修饰*p</p>
<blockquote>
<p><strong>重要</strong></p>
<p><strong>总结</strong>: const修饰指针变量的时候看是修饰*p还是p如果是*p则表示*p的值不能改变,如果修饰p表示p的值不能改变,这个和const用法是一样的,但是需要具体分析其表达的含有:<br><strong>修饰*p(称为指向常量的指针)</strong>,*p的值不能改变,则不能通过这个指针修改变量的值,但是可以直接修改或者其他指针修改变量的值<br><strong>修饰p(成为常量指针)</strong>,p的值不能改变,则指针p只能指向一个固定的地址,如果修饰p但是p未初始化,这这个指针可以指向任意地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p;</span><br><span class="line">p=&amp;num;   <span class="comment">//非法的,const修饰p不能修改p的值,这个时候p是一个可能指向任意地址的野指针(段错误)</span></span><br></pre></td></tr></table></figure>

<p><strong>修饰*p和p(称为指向常量的常量指针)</strong></p>
</blockquote>
<blockquote>
<p><strong>警告</strong></p>
<p>把const指针赋值给非const指针是危险的行为,这样会导致const失效–&gt;其他指针可以直接修改对应地址上面的值</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p1 = &amp;a;</span><br><span class="line"><span class="type">int</span>* p2 = p1;    <span class="comment">//把const指针赋值给const指针,一级指针这样做会报警告,二多级指针直接导致编译错误!!</span></span><br></pre></td></tr></table></figure>







<h3 id="const修饰多级指针"><a href="#const修饰多级指针" class="headerlink" title="const修饰多级指针"></a><code>const</code>修饰多级指针</h3><p><code>const</code>修饰多级指针与上面相似,但是有些方面更加严格,以二级指针为例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> **pptr;   <span class="comment">//const修饰**pptr,即**pptr为常量,不可以用**pptr直接修改对应整数变量上面的值</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span>*pptr;	<span class="comment">//const修饰*pptr,即*pptr为常量,不可以直接修改*pptr的值</span></span><br><span class="line"><span class="type">int</span> **<span class="type">const</span> pptr;	<span class="comment">//const修饰ptr,即这个指针是指针常量,不可以修改这个指针指向的值</span></span><br></pre></td></tr></table></figure>

<p>以上是<code>const</code>修饰多级指针时候和一级指针一样的地方,但是为了防止多级指针间接修改对应的值,多级指针在有个const赋值更加严格</p>
<h2 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a>void*指针</h2><blockquote>
<p>用于接收任意类型指针的指针类型,是一种泛型指针,但是注意这种指针<strong>不可以直接进行加减整数和解引用操作,需要配合强转使用</strong>,但是可以两个void*指针间作减法 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="type">void</span> *pa = &amp;a;</span><br><span class="line">    *(<span class="type">int</span> *)pa = <span class="number">10</span>;  <span class="comment">//解引用pa需要先确定pa指向内存的大小,否则无法确定解引用的结果,偏移也是,需要先知道偏移量,这里都需要先进行强制类型转换使得void*指针转变为特定类型的指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>



<h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p><strong>野指针指的是指向不可用内存区域的指针</strong></p>
<p>举例:</p>
<ul>
<li>未被初始化的指针</li>
<li>数组越界访问(在一些OJ环境越界访问是不允许的)</li>
<li>指针指向的空间释放了<ul>
<li>动态内存分配释放内存没有把NULL赋值给指向这块内存的指针,此时指针指向了不可访问的内存</li>
<li>指向销毁的局部变量和函数栈帧等</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">    *p=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问了不能访问的内存发生错误,会报段错误<code>:Segmentation fault</code></p>
<img data-src="/images/C语言指针学习笔记/20250529131033_013.png" alt="image-20250316105217704"  />

<blockquote>
<p>什么是段错误？<br>段错误是操作系统检测到程序试图访问非法内存地址时发出的信号（通常是 SIGSEGV）。在现代操作系统中，内存被划分为不同的段（如代码段、数据段、堆、栈等），每个段有特定的权限（读、写、执行）。当程序违反这些权限或访问未分配的内存时，就会触发段错误。<br>比如常见的段错误:<strong>读写越界,修改只读内存</strong>(常见的几种)</p>
</blockquote>
<img data-src="/images/C语言指针学习笔记/20250529131033_014.png" alt="image-20250316104725445" style="zoom:67%;" />

<blockquote>
<p><strong>注意</strong></p>
<p>定义指针的时候如果不初始化,把指针定义为NULL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></blockquote>
<h2 id="assert-断言"><a href="#assert-断言" class="headerlink" title="assert:断言"></a>assert:断言</h2><blockquote>
<p><code>assert.h </code>头⽂件定义了宏 <code>assert()</code> ，⽤于在运⾏时确保程序符合指定条件，如果不符合，就报错终⽌运⾏。这个宏常常被称为**”断言”**</p>
</blockquote>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_015.png" alt="image-20250517123010809"></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_016.png" alt="image-20250517123055783"></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_017.png" alt="image-20250517122920608"></p>
<blockquote>
<p><strong>提示</strong></p>
<p>使用<code>assert()</code>函数在调试过程加入一些条件判断,可以鉴定程序是否符合预期运行.如果不符合预期程序就停止运行且显示错误位置和表达式</p>
<p>如果不需要<code>assert</code>,只需在定义宏<code>#define NDEDUG</code>即可跳过<code>assert</code>语句</p>
</blockquote>
<h2 id="万能指针和malloc函数"><a href="#万能指针和malloc函数" class="headerlink" title="万能指针和malloc函数"></a>万能指针和malloc函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无类型指针称为万能指针:</span></span><br><span class="line"><span class="type">void</span>* p;   <span class="comment">//可以通过强制类型转换转换为某种类型指针:(int*)p转换为指向int数据类型的指针</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重要</strong></p>
<p>malloc函数向系统申请内存空间,参数为申请内存空间(堆内存)字节大小,返回值为内存首元素的地址,由于不知道这块地址存放数据类型,故返回void*的指针,需要的时候强制转换成对应类型的指针</p>
</blockquote>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_018.png" alt="image-20250401153132143"></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_019.png" alt="image-20250316110952290"></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_020.png" alt="image-20250316111613885"></p>
<blockquote>
<p><strong>警告</strong></p>
<p>申请完内存空间使用完后需要手动释放,用free函数释放手动申请的内存空间防止内存泄漏,同时把str指针赋值为NULL,因为内存已经释放,不对str赋值为NULL变成野指针(指向不可以内存空间的指针)</p>
</blockquote>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_021.png" alt="image-20250316113440011"></p>
<blockquote>
<p><strong>警告</strong></p>
<p><code>malloc</code>分配内存空间是未初始化的垃圾值,需要先初始化,用<code>memset</code>函数</p>
</blockquote>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_022.png" alt="image-20250401152432625"></p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *output = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">memset</span>(output, <span class="string">&#x27;\0&#x27;</span>, <span class="number">100</span>);  <span class="comment">//将分配内存存储字符修改为&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>或者用<code>calloc</code>函数分配内存空间</p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_023.png" alt="image-20250401152612704"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *output = (<span class="type">char</span>*)<span class="built_in">calloc</span>(<span class="number">100</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>)); </span><br></pre></td></tr></table></figure>

<h2 id="对比malloc和calloc"><a href="#对比malloc和calloc" class="headerlink" title="对比malloc和calloc"></a>对比<code>malloc</code>和<code>calloc</code></h2><p><strong>在 C 语言中，malloc 和 calloc 都是用于动态分配内存的函数，但它们在用法和行为上有一些关键区别。以下是两者的对比，特别是传参和功能的差异：</strong></p>
<h3 id="1-函数签名和传参"><a href="#1-函数签名和传参" class="headerlink" title="1. 函数签名和传参"></a>1. <strong>函数签名和传参</strong></h3><ul>
<li><p><code>malloc</code></p>
<ul>
<li><p>原型：<code>void *malloc(size_t size);</code></p>
</li>
<li><p>参数：只接受一个参数 size，表示要分配的字节数。</p>
</li>
<li><p>返回：指向分配内存的指针（类型为 void*，需要手动转换为目标类型）。</p>
</li>
<li><p>示例：</p>
<p>  <code>char *ptr = (char*)malloc(100); // 分配 100 字节</code></p>
</li>
<li><p>特点：分配的是一块连续的内存，size 是总字节数。</p>
</li>
</ul>
</li>
<li><p><code>calloc</code></p>
<ul>
<li><p>原型：<code>void *calloc(size_t num, size_t size);</code></p>
</li>
<li><p>参数：接受两个参数：</p>
<ul>
<li>num：要分配的元素个数。</li>
<li>size：每个元素的大小（以字节为单位）。</li>
</ul>
</li>
<li><p>返回：指向分配内存的指针（类型为 void*，同样需要手动转换）。</p>
</li>
<li><p>示例：</p>
<p>  <code>char *ptr = (char*)calloc(100, sizeof(char)); // 分配 100 个 char 大小的内存</code></p>
</li>
<li><p>特点：分配的内存大小是 num * size，并且会将所有字节初始化为 0。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-内存初始化"><a href="#2-内存初始化" class="headerlink" title="2. 内存初始化"></a>2. <strong>内存初始化</strong></h3><ul>
<li><p><code>malloc</code></p>
<ul>
<li><p>分配的内存内容是未初始化的，可能是随机值（”垃圾值”）。</p>
</li>
<li><p>如果需要初始化，需要手动调用 memset 或其他方法。</p>
</li>
<li><p>示例：</p>
<p>  <code>char *ptr = (char*)malloc(100); // ptr 的内容是未定义的 memset(ptr, &#39;\0&#39;, 100); // 手动初始化为 &#39;\0&#39;</code></p>
</li>
</ul>
</li>
<li><p><code>calloc</code></p>
<ul>
<li><p>分配的内存会被自动初始化为 0（对于字符来说就是 ‘\0’）。</p>
</li>
<li><p>这是一个内置行为，无需额外操作。</p>
</li>
<li><p>示例：</p>
<p>  <code>char *ptr = (char*)calloc(100, sizeof(char)); // ptr 的 100 个字节已自动初始化为 &#39;\0&#39;</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. <strong>使用场景</strong></h3><ul>
<li><code>malloc</code><ul>
<li>适用于只需要分配内存、不关心初始值的情况。</li>
<li>性能略高于 <code>calloc</code>，因为不执行初始化操作。</li>
</ul>
</li>
<li><code>calloc</code><ul>
<li>适用于需要确保内存初始值为 0 的情况（例如字符串缓冲区或计数器数组）。</li>
<li>参数分离（num 和 size）使得分配多元素数组更直观。</li>
</ul>
</li>
</ul>
<h3 id="4-内存分配的等价性"><a href="#4-内存分配的等价性" class="headerlink" title="4. 内存分配的等价性"></a>4. <strong>内存分配的等价性</strong></h3><ul>
<li><p><code>malloc(100)</code> 和 <code>calloc(100, 1)</code> 在分配的总字节数上是等价的（都是 100 字节），但 <code>calloc</code> 会额外将内存清零。</p>
</li>
<li><p>示例：</p>
<p>  <code>char *m = (char*)malloc(100);           // 100 字节，未初始化 char *c = (char*)calloc(100, sizeof(char)); // 100 字节，初始化为 0</code></p>
</li>
</ul>
<h3 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. <strong>错误处理</strong></h3><ul>
<li><p>两者在分配失败时都返回 <code>NULL</code>，这一点没有区别。</p>
</li>
<li><p>示例：</p>
<p>  <code>char *ptr = (char*)malloc(100); if (ptr == NULL) &#123;    // 分配失败 &#125;</code></p>
</li>
</ul>
<h3 id="总结表"><a href="#总结表" class="headerlink" title="总结表"></a>总结表</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>malloc</code></th>
<th><code>calloc</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>参数</strong></td>
<td>一个：size（总字节数）</td>
<td>两个：num（个数），size（每元素字节数）</td>
</tr>
<tr>
<td><strong>初始化</strong></td>
<td>不初始化，内容未定义</td>
<td>自动初始化为 0</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较快（无初始化开销）</td>
<td>稍慢（有初始化开销）</td>
</tr>
<tr>
<td><strong>典型用途</strong></td>
<td>通用内存分配</td>
<td>需要清零的数组或缓冲区</td>
</tr>
</tbody></table>
<h3 id="实际选择"><a href="#实际选择" class="headerlink" title="实际选择"></a>实际选择</h3><ul>
<li>如果你只需要内存且不在乎初始值，用<code> malloc</code></li>
<li>如果需要内存清零（比如字符串或计数器），用 <code>calloc</code> 会更方便。</li>
</ul>
<h2 id="char-ch和char-arr-区别"><a href="#char-ch和char-arr-区别" class="headerlink" title="char *ch和char arr[]区别"></a><code>char *ch和char arr[]</code>区别</h2><p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_024.png" alt="image-20250423070924107"></p>
<blockquote>
<p>把字符串常量赋值给数组(只有初始化的时候可以这样)会把这个字符串常量赋值到栈区,<strong>把整个字符串拷贝给数组</strong>,而把字符串常量赋值给指针变量,会把首元素地址赋值给指针,这个时候<strong>指针指向静态区的字符串常量</strong></p>
</blockquote>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="函数指针定义"><a href="#函数指针定义" class="headerlink" title="函数指针定义"></a>函数指针定义</h3><blockquote>
<p><strong>重要</strong></p>
<p>首先区分一下数组指针和函数指针,数组名退化和函数名退化规则</p>
<ul>
<li><p>数组名在除<code>&amp;arr</code>和<code>sizeof(arr)</code>之外会退化(<strong>隐式转换</strong>)为首元素地址,<code>type_t arr[len]</code>中<code>arr</code>从<code>type_t [len]</code>类型退化为<code>type_t *</code>类型,即退化为首元素的地址(指针)</p>
</li>
<li><p>而函数名有所不同除<code>&amp;function</code>和<code>sizeof(function)</code>外(这里补充一下对函数进行<code>sizeof(function)</code>是不合法的,因为标准禁止 <code>sizeof</code> 函数类型C11 §6.5.3.4&#x2F;1 只允许对”对象”或完整的类型做 <code>sizeof，</code>函数既不是对象，也不是完整的可测类型,如果需要计算函数入口地址的大小可以<code>sizeof(&amp;fun)</code>,由于函数名在面对&amp;操作符的时候不会退化为入口地址,这个时候对函数名取地地址得到函数的入口地址,再用<code>sizeof</code>即可),<code>type_t function(parameter)</code>中<code>function</code>会从<code>type_t (parameter)</code>类型退化为(<strong>隐式转换</strong>)为<code>type_t (*)(parameter)</code>类型,表示的是函数的入口地址,我们又发现,不发生隐式转换的情况的是对函数取地址,其实对函数取地址<code>&amp;function</code>恰好是<code>type_t (*)(parameter)</code>类型,<strong>即<code>&amp;function</code>和<code>function</code>是等价的</strong>,这个是与数组不同的地方,原因是数组名和函数名隐式转换的类型不同,一个转换为首元素的地址,一个转换为<strong>函数入口地址</strong></p>
</li>
</ul>
</blockquote>
<p>⭐<code>&amp;fun</code>和<code>fun</code>是等价的(<strong>隐式转换的原因</strong>)</p>
<blockquote>
<p>根据前⾯学习整型指针，数组指针的时候，我们的类比关系，我们不难得出结论：<strong>函数指针变量应该是⽤来存放函数地址的，未来通过地址能够调⽤函数的</strong>。</p>
</blockquote>
<p>函数指针是变量存储函数的地址,对函数名取地址<code>&amp;function</code>得到函数的地址,这个与对数组名取地址得到数组的地址一致,这个时候需要用函数指针接收这个地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*p)()=test;  <span class="comment">//指向函数的指针(test和&amp;test等价,都是函数入口地址)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;test =%p\n&quot;</span>,&amp;test);   <span class="comment">//分别打印&amp;test,test,p的值发现三个值完全一样,</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test  =%p\n&quot;</span>,test);	   <span class="comment">//&amp;test函数的地址(入口地址),用函数指针的指针接收,</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p     =%p\n&quot;</span>,p);	   <span class="comment">//但是函数名又会退化为函数入口地址,所以test与&amp;test完全等价</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_025.png" alt="image-20250519144648181"></p>
<blockquote>
<p><strong>提示</strong></p>
<p>类似数组指针,使用函数指针需要用到函数调用操作符<code>()</code>(使用数组指针使用的是数组下标运算符<code>[]</code>)</p>
</blockquote>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_026.png" alt="image-20250518163745953"></p>
<blockquote>
<p><strong>提示</strong></p>
<p>注意函数指针定义的时候可以<strong>省略函数参数名,也可以不省略,没什么影响</strong>,反正使用函数指针调用函数的时候需要传实际参数,省不省略参数名参数名都不起作用</p>
</blockquote>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> (*pf)(<span class="type">int</span>,<span class="type">int</span> )=add;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,pf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_027.png" alt="image-20250518165008144"></p>
<p>下面从”类型转换”角度来看 <code>*add</code> 到底是什么意思：(<strong>函数设计器&#x3D;函数名</strong>)</p>
<ol>
<li><p>函数名的默认转换</p>
<ul>
<li>在大多数表达式中，写到 <code>add</code>（函数设计器）时，编译器会把它隐式转换成”指向该函数的指针”，类型是 <code>int (*)(int,int)</code>。</li>
<li>所以 <code>add</code> ≡ <code>&amp;add</code>，二者都是函数入口地址。</li>
</ul>
</li>
<li><p>对函数指针做一元 <code>*</code></p>
<ul>
<li><code>add</code> 先变成一个指针，然后 <code>*add</code> 就是”解引用”这个指针，得到一个函数设计器，类型回退到”函数类型” <code>int(int,int)</code>。</li>
<li>但是，<strong>在除 <code>sizeof</code>&#x2F;<code>&amp;</code>&#x2F;<code>_Alignof</code> 之外的几乎所有上下文中</strong>，这个函数设计器又会马上再”退化”成指向它的指针。</li>
</ul>
</li>
<li><p>在 <code>printf(&quot;%p\n&quot;, *add);</code> 中的流程：</p>
<ol>
<li><code>add </code>→ 隐式转换 → <code>int (*)(int,int)</code> 类型的函数指针</li>
<li><code>*add</code> → 解引用 → 得到函数设计器，类型 <code>int(int,int)</code></li>
<li>作为 <code>printf</code>参数，又触发函数设计器→函数指针的隐式转换→ 最终传进去的还是那个入口地址</li>
</ol>
</li>
<li><p>和调用写法对比</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*pf)(<span class="type">int</span>,<span class="type">int</span>) = add;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = pf(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">// *pf → 解引用 → 函数设计器 → 隐式转回指针 → 调用*</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = (*pf)(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// *显式先解引用，再调用，效果完全一样*</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>小结：</strong></p>
<ul>
<li><code>*add</code> 并不是一个新函数或特殊符号，只是”对函数指针解引用”→得到函数设计器→ 再次退化成指针。</li>
<li>因此 <code>add</code>、<code>&amp;add</code>、<code>*add</code>、<code>pf</code> 在打印地址时都一样。</li>
</ul>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_028.png" alt="image-20250519145109904"></p>
<h3 id="函数指针使用"><a href="#函数指针使用" class="headerlink" title="函数指针使用"></a>函数指针使用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> (*pf)(<span class="type">int</span> ,<span class="type">int</span> )=add;<span class="comment">//或者&amp;add,二者等价</span></span><br><span class="line">    <span class="comment">//使用函数指针,类型数组指针解引用得到数组元素,对函数指针解引用得到函数.但是由于数组和函数隐式转换有点不同的原因,这里也有些区别</span></span><br><span class="line">    (*pf)(<span class="number">20</span>,<span class="number">30</span>); <span class="comment">//对pf解引用,由于pf存储的是函数入口地址,则*pf得到add,再使用函数调用操作符()调用函数,由前面可知*pf和pf是等价的,因为除sizeof和&amp;以,函数都退化(隐式转换)为入口地址,即此时*pf得到函数,退化为入口地址</span></span><br><span class="line">  	<span class="comment">//使用函数指针等价于</span></span><br><span class="line">    pf(<span class="number">20</span>,<span class="number">30</span>); <span class="comment">//甚至可以(**************pf)(20,30),反正都是等价的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有趣的代码"><a href="#有趣的代码" class="headerlink" title="有趣的代码"></a>有趣的代码</h4><ul>
<li><pre><code class="language-c">  (*(void (*)())0)(); //与((void(*)())0)()等价
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	**解释:**`void (*)()`是一个函数指针类型,把0强转为`void (*)()`类型,然后对调用函数指针0,**从中可得到一个把函数指针置空的方法**:`void (*p)()=(void (*)())0`,即把0强转为相应类型的指针,实际上一级指针的空指针类型NULL在定义的时候就是这样做的:`#define NULL ((void *)0)`也是把0强转为相应指针类型,</span><br><span class="line"></span><br><span class="line">	也可以让其隐式转换为相应的类型置空:`void (*p)()=0`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">	void (*signal(int , void(*)(int)))(int);</span><br></pre></td></tr></table></figure>

  **解释:**声明函数`signal`有两个参数,一个是int类型,一个是返回值是void,参数是 int 的函数指针,这个函数的返回值是一个指针,指针指向的是一个返回值是void ,参数是int的函数
</code></pre>
</li>
</ul>
<p>有上面两个例子看出复杂 的指针晦涩难懂,所以引入类型重定义关键字<code>typedef</code></p>
<h2 id="关键字typedef"><a href="#关键字typedef" class="headerlink" title="关键字typedef"></a>关键字typedef</h2><p><code>typedef</code>是C语言中的关键字，用于为类型创建别名，使复杂的类型声明更易读、更易维护。特别是对于复杂的函数指针类型，使用<code>typedef</code>可以大大提高代码的可读性。</p>
<p>例如，可以将复杂的函数指针类型定义为更简单的形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用typedef的函数指针声明</span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span>, <span class="type">void</span> (*)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用typedef简化</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">signal_handler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">signal_handler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span>, <span class="type">signal_handler_t</span>)</span>;</span><br></pre></td></tr></table></figure>


<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_029.png" alt="image-20250519164714731"></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_030.png" alt="image-20250519165426862"></p>
<h2 id="qsort函数"><a href="#qsort函数" class="headerlink" title="qsort函数"></a><code>qsort</code>函数</h2><p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_031.png" alt="image-20250519171134505"></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_032.png" alt="image-20250519171615064"></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_033.png" alt="image-20250519172320200"></p>
<blockquote>
<p><code>qsort</code>函数接收四个参数(实现排序任意类型的数据)</p>
<ol>
<li><p>首元素地址</p>
</li>
<li><p>元素个数</p>
</li>
<li><p>每个元素占用字节大小</p>
</li>
<li><p><strong>排序比较函数指针<code>int(*)(const void*,conts void *)</code>类型的函数指针</strong></p>
<p> <strong>注意:<strong>传第四个参数的时候类型要匹配,即一定要传<code>int(*)(const void*,conts void *)</code>类型的函数指针,否则类型不匹配报错,所以我们自己定义比较函数的时候返回类型和参数必须保持一致,否则参数类型不匹配</strong>(当然也可以在传参的时候强转,见下面示例代码)</strong></p>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	qsort函数排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//正常传参int(*)(const void*,const void*)类型函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *x, <span class="type">const</span> <span class="type">void</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">int</span> *)x) - *((<span class="type">int</span> *)y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">423</span>, <span class="number">55</span>, <span class="number">54646</span>, <span class="number">4243</span>, <span class="number">54654</span>, <span class="number">4243</span>, <span class="number">6546</span>, <span class="number">8567</span>, <span class="number">3132</span>, <span class="number">546</span>&#125;;</span><br><span class="line">    qsort(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), compare);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对函数指针类型强转为qsort需要的类型传参</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> *y)</span>  <span class="comment">//比较函数 int (*)(int *,int*)类型函数指针接收</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *x-*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">423</span>, <span class="number">55</span>, <span class="number">54646</span>, <span class="number">4243</span>, <span class="number">54654</span>, <span class="number">4243</span>, <span class="number">6546</span>, <span class="number">8567</span>, <span class="number">3132</span>, <span class="number">546</span>&#125;;</span><br><span class="line">    qsort(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), (<span class="type">int</span>(*)(<span class="type">const</span> <span class="type">void</span>*,<span class="type">const</span> <span class="type">void</span>*))compare);   <span class="comment">//把函数指针类型强转为int (*)(const void*,const void *)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释强转传参的合理性:</strong></p>
<blockquote>
<p><strong>提示</strong></p>
<p>把比较函数指针强转为<code>int (*)(const void *,const void *)</code>类型,用<code>compare</code>函数指针变量接收这个地址,<code>qsort</code>函数内部使用<code>compare</code>函数指针变量调用回调函数的时候把函数指针的两个<code>const void*</code>类型参数传给回调函数,而回调函数的参数是普通的<code>const</code>指针类型不是泛型指针,<strong>此时发生隐式转换,把<code>const void*</code>指针转换为<code>const</code>普通类型指针</strong>,从而达到目的</p>
</blockquote>
<p>**示例:**使用<code>qsort</code>排序其他数据类型-&gt;结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125; persion;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(persion *arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i].year); <span class="comment">//也可以使用-&gt;操作符,类似数组[]操作符,-&gt;和(*arr).year</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);					<span class="comment">//等价,即可以(arr+i)-&gt;year,和下标运算符非常类似,用于结构体</span></span><br><span class="line">&#125;									<span class="comment">//指针直接访问成员</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *x, <span class="type">const</span> <span class="type">void</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">const</span> persion*)x)-&gt;year-((<span class="type">const</span> persion*)y)-&gt;year;</span><br><span class="line">    <span class="comment">//⭐把const void*指针强转为结构体指针const persion*类型--解引用--访问成员year</span></span><br><span class="line">&#125;	<span class="comment">//													 或者使用指向结构体成员操作符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    persion arr[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        arr[i].year = rand() % <span class="number">60</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前:\n&quot;</span>);</span><br><span class="line">    print(arr, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]));</span><br><span class="line">    qsort(arr, <span class="number">20</span>, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), compare);</span><br><span class="line">    print(arr, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果<br><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_034.png" alt="image-20250519182058443"></p>
<p><u><strong>指针通关测试题</strong></u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *c[] = &#123;<span class="string">&quot;ENTER&quot;</span>, <span class="string">&quot;NEW&quot;</span>, <span class="string">&quot;POINT&quot;</span>, <span class="string">&quot;FIRST&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> **cp[] = &#123;c + <span class="number">3</span>, c + <span class="number">2</span>, c + <span class="number">1</span>, c&#125;;</span><br><span class="line">    <span class="type">char</span> ***cpp = cp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, **++cpp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *--*++cpp + <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *cpp[<span class="number">-2</span>] + <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, cpp[<span class="number">-1</span>][<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p><img data-src="/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_035.png" alt="image-20250522152448746"></p>
<h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p>这道题涉及到多级指针的操作，需要逐行分析每一条语句的执行过程：</p>
<ol>
<li><p>首先来看数据初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *c[] = &#123;<span class="string">&quot;ENTER&quot;</span>, <span class="string">&quot;NEW&quot;</span>, <span class="string">&quot;POINT&quot;</span>, <span class="string">&quot;FIRST&quot;</span>&#125;;  <span class="comment">// 字符串指针数组</span></span><br><span class="line"><span class="type">char</span> **cp[] = &#123;c + <span class="number">3</span>, c + <span class="number">2</span>, c + <span class="number">1</span>, c&#125;;  <span class="comment">// 指向字符指针的指针数组</span></span><br><span class="line"><span class="type">char</span> ***cpp = cp;  <span class="comment">// 指向指针数组的指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第一条打印语句：<code>printf(&quot;%s\n&quot;, **++cpp);</code></p>
<ul>
<li><code>++cpp</code>: cpp先自增，从指向cp[0]变为指向cp[1]，即指向c+2</li>
<li><code>**++cpp</code>: 解引用两次，即 **(c+2) &#x3D; *(c+2) &#x3D; “POINT”</li>
<li>所以打印出 “POINT”</li>
</ul>
</li>
<li><p>第二条打印语句：<code>printf(&quot;%s\n&quot;, *--*++cpp + 3);</code></p>
<ul>
<li><code>++cpp</code>: cpp再次自增，指向cp[2]，即c+1</li>
<li><code>*++cpp</code>: 解引用得到c+1</li>
<li><code>--*++cpp</code>: 将c+1减1，得到c</li>
<li><code>*--*++cpp</code>: 解引用c，得到”ENTER”</li>
<li><code>*--*++cpp + 3</code>: 字符串”ENTER”偏移3个字符，得到”ER”</li>
<li>所以打印出 “ER”</li>
</ul>
</li>
<li><p>第三条打印语句：<code>printf(&quot;%s\n&quot;, *cpp[-2] + 3);</code></p>
<ul>
<li><code>cpp[-2]</code>: 等价于*(cpp-2)，cpp当前指向cp[2]，向前偏移2个位置指向cp[0]，即c+3</li>
<li><code>*cpp[-2]</code>: 解引用c+3，得到”FIRST”</li>
<li><code>*cpp[-2] + 3</code>: 字符串”FIRST”偏移3个字符，得到”ST”</li>
<li>所以打印出 “ST”</li>
</ul>
</li>
<li><p>第四条打印语句：<code>printf(&quot;%s\n&quot;, cpp[-1][-1] + 1);</code></p>
<ul>
<li><code>cpp[-1]</code>: 等价于*(cpp-1)，cpp当前指向cp[2]，向前偏移1个位置指向cp[1]，即c+2</li>
<li><code>cpp[-1][-1]</code>: 等价于*(*(cpp-1)-1)，先得到c+2，再减1得到c+1，解引用得到”NEW”</li>
<li><code>cpp[-1][-1] + 1</code>: 字符串”NEW”偏移1个字符，得到”EW”</li>
<li>所以打印出 “EW”</li>
</ul>
</li>
</ol>
<p>这道题考察了多级指针、指针运算、数组访问以及字符串指针操作的综合应用，是理解指针概念的一个很好的练习。</p>
<h1 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h1><h2 id="指针的核心概念回顾"><a href="#指针的核心概念回顾" class="headerlink" title="指针的核心概念回顾"></a>指针的核心概念回顾</h2><ol>
<li><p><strong>指针的本质</strong>：指针是一种特殊的变量，它存储的是内存地址。通过指针，我们可以间接访问和操作内存中的数据。</p>
</li>
<li><p><strong>指针的分类</strong>：</p>
<ul>
<li>基本数据类型指针（如 <code>int*</code>, <code>char*</code>）</li>
<li>数组指针</li>
<li>函数指针</li>
<li>多级指针（如二级指针 <code>int**</code>）</li>
<li>泛型指针（<code>void*</code>）</li>
</ul>
</li>
<li><p><strong>指针操作</strong>：</p>
<ul>
<li>取地址操作：使用 <code>&amp;</code> 获取变量的地址</li>
<li>解引用操作：使用 <code>*</code> 访问指针指向的内存中的值</li>
<li>指针运算：加减操作、指针比较等</li>
</ul>
</li>
<li><p><strong>特殊用法</strong>：</p>
<ul>
<li>函数指针和回调函数</li>
<li>指针与数组的关系</li>
<li><code>const</code> 修饰的指针</li>
<li>多级指针的应用</li>
</ul>
</li>
</ol>
<h2 id="指针使用的注意事项"><a href="#指针使用的注意事项" class="headerlink" title="指针使用的注意事项"></a>指针使用的注意事项</h2><ol>
<li><p><strong>内存安全</strong>：使用指针时要特别注意内存安全问题，避免：</p>
<ul>
<li>使用未初始化的指针</li>
<li>访问已释放的内存（悬垂指针）</li>
<li>缓冲区溢出</li>
<li>内存泄漏</li>
</ul>
</li>
<li><p><strong>野指针防范</strong>：养成良好习惯，初始化指针为 <code>NULL</code>，在使用前检查指针是否为 <code>NULL</code>，释放内存后将指针置为 <code>NULL</code>。</p>
</li>
<li><p><strong>理解指针与数组的区别</strong>：尽管数组名在大多数情况下会退化为指向首元素的指针，但它们在本质上是不同的。</p>
</li>
</ol>
<h2 id="指针的意义与价值"><a href="#指针的意义与价值" class="headerlink" title="指针的意义与价值"></a>指针的意义与价值</h2><p>指针是C语言的强大特性，它使程序员能够：</p>
<ol>
<li><strong>直接操作内存</strong>：实现高效的内存管理和数据结构</li>
<li><strong>实现复杂的数据结构</strong>：链表、树、图等</li>
<li><strong>提高程序效率</strong>：通过传递指针而非整个数据结构来减少数据复制</li>
<li><strong>实现动态内存分配</strong>：根据程序运行时的需求分配内存</li>
</ol>
<p>通过深入理解和正确使用指针，我们可以编写出更高效、更灵活的C语言程序。然而，指针的灵活性也带来了潜在的风险，因此在使用指针时必须保持谨慎，并采取必要的防范措施避免出现内存相关的问题。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>技术笔记</tag>
      </tags>
  </entry>
</search>
