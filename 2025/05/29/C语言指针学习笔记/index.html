<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.huluapple.xin","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"text":"加载 Gitalk","order":-1}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C语言指针是C语言的精髓，本文详细介绍指针的基本概念、使用技巧和常见陷阱。从指针基础到函数指针、回调函数，再到动态内存管理，全面解析C语言中最关键也最容易出错的知识点，帮助读者彻底掌握C语言指针的使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言指针学习笔记">
<meta property="og:url" content="https://blog.huluapple.xin/2025/05/29/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hulu&#39;s Blog">
<meta property="og:description" content="C语言指针是C语言的精髓，本文详细介绍指针的基本概念、使用技巧和常见陷阱。从指针基础到函数指针、回调函数，再到动态内存管理，全面解析C语言中最关键也最容易出错的知识点，帮助读者彻底掌握C语言指针的使用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_001.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131035_002.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131036_003.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131038_004.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131039_005.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131041_006.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131043_007.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131044_008.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131046_009.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131047_010.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131049_011.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131050_012.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131103_013.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131103_014.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131055_015.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131056_016.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131057_017.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131106_018.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131107_019.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131108_020.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131103_021.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131106_022.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131107_023.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131108_024.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131109_025.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131111_026.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131112_027.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131113_028.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131116_029.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131117_030.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131120_031.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131121_032.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131122_033.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131123_034.png">
<meta property="og:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131124_035.png">
<meta property="article:published_time" content="2025-05-29T05:00:21.000Z">
<meta property="article:modified_time" content="2025-05-29T05:00:21.000Z">
<meta property="article:author" content="Hulu">
<meta property="article:tag" content="C语言">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="技术分享">
<meta property="article:tag" content="指针">
<meta property="article:tag" content="内存管理">
<meta property="article:tag" content="函数指针">
<meta property="article:tag" content="回调函数">
<meta property="article:tag" content="动态内存分配">
<meta property="article:tag" content="野指针">
<meta property="article:tag" content="const修饰符">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.huluapple.xin/images/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20250529131033_001.png">


<link rel="canonical" href="https://blog.huluapple.xin/2025/05/29/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.huluapple.xin/2025/05/29/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","path":"2025/05/29/C语言指针学习笔记/","title":"C语言指针学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C语言指针学习笔记 | Hulu's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hulu's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">A place to share my thoughts</p>
      <img class="custom-logo-image" src="/images/hacker.png" alt="Hulu's Blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-资源"><a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">1.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">指针介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%95%BF%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">步长(偏移量)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="nav-number">1.1.2.</span> <span class="nav-text">指针运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sizeof-%E4%B8%8Estrlen%E6%AF%94%E8%BE%83"><span class="nav-number">1.1.3.</span> <span class="nav-text">sizeof
与strlen比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88"><span class="nav-number">1.2.</span> <span class="nav-text">const修饰指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E4%BF%AE%E9%A5%B0%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88"><span class="nav-number">1.2.1.</span> <span class="nav-text">const修饰多级指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#void%E6%8C%87%E9%92%88"><span class="nav-number">1.3.</span> <span class="nav-text">void*指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8E%E6%8C%87%E9%92%88"><span class="nav-number">1.4.</span> <span class="nav-text">野指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#assert%E6%96%AD%E8%A8%80"><span class="nav-number">1.5.</span> <span class="nav-text">assert:断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%87%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8Cmalloc%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.</span> <span class="nav-text">万能指针和malloc函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94malloc%E5%92%8Ccalloc"><span class="nav-number">1.7.</span> <span class="nav-text">对比malloc和calloc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E5%92%8C%E4%BC%A0%E5%8F%82"><span class="nav-number">1.7.1.</span> <span class="nav-text">1. 函数签名和传参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.7.2.</span> <span class="nav-text">2. 内存初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.7.3.</span> <span class="nav-text">3. 使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="nav-number">1.7.4.</span> <span class="nav-text">4. 内存分配的等价性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.7.5.</span> <span class="nav-text">5. 错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E8%A1%A8"><span class="nav-number">1.7.6.</span> <span class="nav-text">总结表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E9%80%89%E6%8B%A9"><span class="nav-number">1.7.7.</span> <span class="nav-text">实际选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#char-ch%E5%92%8Cchar-arr%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.</span> <span class="nav-text">char *ch和char arr[]区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">1.9.</span> <span class="nav-text">函数指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AE%9A%E4%B9%89"><span class="nav-number">1.9.1.</span> <span class="nav-text">函数指针定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qsort%E5%87%BD%E6%95%B0"><span class="nav-number">1.11.</span> <span class="nav-text">qsort函数</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hulu"
      src="/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250331171042.jpg">
  <p class="site-author-name" itemprop="name">Hulu</p>
  <div class="site-description" itemprop="description">Welcome to my blog where I share my thoughts and experiences.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hulu798" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hulu798" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/contact/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250331172758.jpg" title="WeChat → &#x2F;images&#x2F;contact&#x2F;微信图片_20250331172758.jpg" rel="noopener me"><i class="fab fa-weixin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/contact/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250331172807.jpg" title="QQ → &#x2F;images&#x2F;contact&#x2F;微信图片_20250331172807.jpg" rel="noopener me"><i class="fab fa-qq fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/hulu1199453" title="X → https:&#x2F;&#x2F;twitter.com&#x2F;hulu1199453" rel="noopener me" target="_blank"><i class="fab fa-x-twitter fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/29760590" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;29760590" rel="noopener me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.huluapple.xin/2025/05/29/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250331171042.jpg">
      <meta itemprop="name" content="Hulu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulu's Blog">
      <meta itemprop="description" content="Welcome to my blog where I share my thoughts and experiences.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C语言指针学习笔记 | Hulu's Blog">
      <meta itemprop="description" content="C语言指针是C语言的精髓，本文详细介绍指针的基本概念、使用技巧和常见陷阱。从指针基础到函数指针、回调函数，再到动态内存管理，全面解析C语言中最关键也最容易出错的知识点，帮助读者彻底掌握C语言指针的使用。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C语言指针学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-29 13:00:21" itemprop="dateCreated datePublished" datetime="2025-05-29T13:00:21+08:00">2025-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/study-notes/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/study-notes/tech-sharing/" itemprop="url" rel="index"><span itemprop="name">技术分享</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/study-notes/tech-sharing/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

            <div class="post-description">C语言指针是C语言的精髓，本文详细介绍指针的基本概念、使用技巧和常见陷阱。从指针基础到函数指针、回调函数，再到动态内存管理，全面解析C语言中最关键也最容易出错的知识点，帮助读者彻底掌握C语言指针的使用。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><!-- 目录自动生成，通过页面配置toc:true实现 -->
<blockquote>
<p>指针是C语言的精髓，也是C语言相对其他高级语言的一大特色。正确理解和使用指针对于深入学习C语言至关重要。本文将从基本概念出发，详细介绍各种指针类型、指针操作以及常见应用场景，帮助读者全面掌握C语言指针。</p>
</blockquote>
<h1 id="指针">指针</h1>
<h2 id="指针介绍">指针介绍</h2>
<blockquote>
<p><strong>警告</strong></p>
<p>*号在不同地方意义不同</p>
<ul>
<li>*前面有类型:表示指针</li>
<li>*前面没有类型:表示解引用运算符</li>
</ul>
</blockquote>
<ul>
<li><p>通常的指针是指针变量的简称,是一个指向对象地址的变量指针以指向对象的类型不同分为很多种不同的指针,比如说指向int的一级指针,int**的二级指针<span
class="math inline">\(…\)</span></p></li>
<li><p><strong>指针做加减元素,地址变化的值是:加减的整数乘上指针指向的数据类型占用字节大小</strong></p></li>
</ul>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p=&amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n%p\n&quot;</span>,p,p+<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针变化的值是<span class="math inline">\(4*4=16\)</span></p>
<blockquote>
<p><strong>注意</strong></p>
<p>专门用%td表示两个相同类型的指针的差值(相同类型的意思是指向相同类型的数据,比如说都指向int,指向int*)</p>
</blockquote>
<ul>
<li><p>两个指针的比较</p>
<p>使用关系运算符可以比较两个指针的值，前提是两个指针都指向使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象</p></li>
</ul>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131033_001.png"
alt="指针比较代码示例" />
<figcaption aria-hidden="true">指针比较代码示例</figcaption>
</figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131035_002.png"
alt="指针与数组的比较" />
<figcaption aria-hidden="true">指针与数组的比较</figcaption>
</figure>
<blockquote>
<p><strong>重要</strong></p>
<p><strong>给函数形参加const防止改变数组元素:</strong></p>
</blockquote>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131036_003.png"
alt="const防止修改数组元素示例1" />
<figcaption aria-hidden="true">const防止修改数组元素示例1</figcaption>
</figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131038_004.png"
alt="const防止修改数组元素示例2" />
<figcaption aria-hidden="true">const防止修改数组元素示例2</figcaption>
</figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131039_005.png"
alt="const防止修改数组元素示例3" />
<figcaption aria-hidden="true">const防止修改数组元素示例3</figcaption>
</figure>
<h3 id="步长偏移量">步长(偏移量)</h3>
<p>步长取决于指针指向变量的类型</p>
<p>注意对指针加减都是以元素为单位计量的,比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> *ptr1=(arr+<span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> *ptr2=(arr+<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> len=ptr1-ptr2 ;<span class="comment">//得到的是2,而不是8</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131041_006.png"
alt="指针步长计算示例" />
<figcaption aria-hidden="true">指针步长计算示例</figcaption>
</figure>
<h3 id="指针运算">指针运算</h3>
<blockquote>
<p><strong>提示</strong></p>
<p><strong>一条语句(语句以分号为结束)多个变量声明的时候,指针指向的类型和*分开,类型在最前面,*和变量连在一起</strong></p>
</blockquote>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131043_007.png"
alt="多个指针变量声明语法" />
<figcaption aria-hidden="true">多个指针变量声明语法</figcaption>
</figure>
<h3 id="sizeof-与strlen比较"><code>sizeof</code>
与<code>strlen</code>比较</h3>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131044_008.png"
alt="sizeof函数用法示例" />
<figcaption aria-hidden="true">sizeof函数用法示例</figcaption>
</figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131046_009.png"
alt="sizeof与strlen对比示例1" />
<figcaption aria-hidden="true">sizeof与strlen对比示例1</figcaption>
</figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131047_010.png"
alt="sizeof与strlen对比示例2" />
<figcaption aria-hidden="true">sizeof与strlen对比示例2</figcaption>
</figure>
<p>⭐⭐⭐<strong>示例代码使用<code>sizeof</code>,主要理解数组名发生隐式转换(退化)为首元素地址的例外情况</strong></p>
<blockquote>
<p><strong>警告</strong></p>
<p>注意只有<code>sizeof+数组</code>和<code>&amp;+数组</code>数组名才不会隐式转换为首元素地址,<strong>要是放的不是数组名或者数组名等价表示(如<code>*&amp;arr</code>)均会隐式转换为地址</strong>,下面的函数名退化规则和数组
名退化规则完全一致,只不过函数名退化为函数入口地址,和<code>&amp;函数名</code>结果一样,省去很多麻烦,以后如果数组不是以上两种情况不隐式转换的时候,<strong>都需要使用首元素地址去分析问题</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(a));      <span class="comment">//16,sizeof(数组名)此时数组名不会隐式转换为地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(a + <span class="number">0</span>));	 <span class="comment">//⭐8,a+0转换为(多了+0导致的)首元素地址,然后再计算地址大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(*a));     <span class="comment">//4,一个int类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(a + <span class="number">1</span>));	 <span class="comment">//8,同上</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">1</span>]));	 <span class="comment">//4,int类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));	 <span class="comment">//8,&amp;+数组名数组不会隐式转换,此时&amp;a表示整个数组地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(*&amp;a));    <span class="comment">//⭐16,&amp;a整个数组地址,再解引用得到数组,sizeof(数组名)不退化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;*a));    <span class="comment">//⭐8,表示首元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a + <span class="number">1</span>)); <span class="comment">//8,一个地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]));  <span class="comment">//8一个地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>] + <span class="number">1</span>)); <span class="comment">//8,一个地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131049_011.png"
alt="sizeof与数组名退化示例" />
<figcaption aria-hidden="true">sizeof与数组名退化示例</figcaption>
</figure>
<blockquote>
<p><strong>提示</strong></p>
<p>⭐⭐⭐使用<code>strlen</code>函数计算字符串长度传入的参数是<code>cosnt char*</code>类型,第三和第四的个传入<code>char</code>类型,<strong>会强转为指针类型,但是该地址不可访问导致段错误,倒数第二,三个也会强转,但是强转后还是指针,是可访问的</strong></p>
</blockquote>
<p><strong>练习</strong></p>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131050_012.png"
alt="数组指针和二维数组练习题" />
<figcaption aria-hidden="true">数组指针和二维数组练习题</figcaption>
</figure>
<blockquote>
<p><strong>答案:</strong></p>
<ol type="1">
<li>第3个<code>a[0]</code>代表第一行,<code>sizof</code>直接加数组不会隐式转换为首元素指针,所以是16</li>
<li>第4个<code>a[0]+1</code>,数组名退化为首元素指针,结果是4/8</li>
<li>第5个<code>*(a[0]+1)</code>代表第二行,直接<code>sizeof</code>不会隐式转换为指针</li>
<li>第6个同上退化为指针,结果8</li>
<li>第7个代表第二行,而且直接在<code>sizeof</code>后面,结果16</li>
<li>第8个<code>sizeof(&amp;a[0]+1)</code>,对第一行取地址得到第一行地址,加一得到第二行地址,<code>sizeof</code>计算得8</li>
</ol>
<p><strong>关键分析出数组是否退化(隐式转换)为首元素指针,只有<code>&amp;+数组</code>和<code>sizeof+数组</code>才不会隐式转换,需要分清</strong></p>
</blockquote>
<h2 id="const修饰指针">const修饰指针</h2>
<blockquote>
<p>前言
即使是const修饰变量,指针还是可以操作地址改变其值,因为const修饰作用是限制直接修改变量的值,从而有了const修饰指针</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=&amp;num; <span class="comment">//和int const *p等价,相当于int可以忽略,const直接修饰*p</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p=&amp;num;  <span class="comment">//const在p右边修饰p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象不同导致作用不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const int *p:修饰的是*p表示指针指向的是常变量,不能修改*p(注意*p不能修改而已,但是可以通过其他指针或者num本身修改num值)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int* const p:修饰的是指针p,表示p的值不能改变,即p只能指向&amp;num,p++非法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p=&amp;num; <span class="comment">//既修饰*p也修饰p,表示*p和p都不可以修改</span></span><br></pre></td></tr></table></figure>
<p>注:const修饰int *p的时候*理解为解引用表示const修饰*p</p>
<blockquote>
<p><strong>重要</strong></p>
<p><strong>总结</strong>:
const修饰指针变量的时候看是修饰*p还是p如果是*p则表示*p的值不能改变,如果修饰p表示p的值不能改变,这个和const用法是一样的,但是需要具体分析其表达的含有:
**修饰*p(称为指向常量的指针)<strong>,*p的值不能改变,则不能通过这个指针修改变量的值,但是可以直接修改或者其他指针修改变量的值
</strong>修饰p(成为常量指针)**,p的值不能改变,则指针p只能指向一个固定的地址,如果修饰p但是p未初始化,这这个指针可以指向任意地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p;</span><br><span class="line">p=&amp;num;   <span class="comment">//非法的,const修饰p不能修改p的值,这个时候p是一个可能指向任意地址的野指针(段错误)</span></span><br></pre></td></tr></table></figure>
<p><strong>修饰*p和p(称为指向常量的常量指针)</strong></p>
</blockquote>
<blockquote>
<p><strong>警告</strong></p>
<p>把const指针赋值给非const指针是危险的行为,这样会导致const失效–&gt;其他指针可以直接修改对应地址上面的值</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p1 = &amp;a;</span><br><span class="line"><span class="type">int</span>* p2 = p1;    <span class="comment">//把const指针赋值给const指针,一级指针这样做会报警告,二多级指针直接导致编译错误!!</span></span><br></pre></td></tr></table></figure>
<h3 id="const修饰多级指针"><code>const</code>修饰多级指针</h3>
<p><code>const</code>修饰多级指针与上面相似,但是有些方面更加严格,以二级指针为例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> **pptr;   <span class="comment">//const修饰**pptr,即**pptr为常量,不可以用**pptr直接修改对应整数变量上面的值</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span>*pptr;	<span class="comment">//const修饰*pptr,即*pptr为常量,不可以直接修改*pptr的值</span></span><br><span class="line"><span class="type">int</span> **<span class="type">const</span> pptr;	<span class="comment">//const修饰ptr,即这个指针是指针常量,不可以修改这个指针指向的值</span></span><br></pre></td></tr></table></figure>
<p>以上是<code>const</code>修饰多级指针时候和一级指针一样的地方,但是为了防止多级指针间接修改对应的值,多级指针在有个const赋值更加严格</p>
<h2 id="void指针">void*指针</h2>
<blockquote>
<p>用于接收任意类型指针的指针类型,是一种泛型指针,但是注意这种指针<strong>不可以直接进行加减整数和解引用操作,需要配合强转使用</strong>,但是可以两个void*指针间作减法</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="type">void</span> *pa = &amp;a;</span><br><span class="line">    *(<span class="type">int</span> *)pa = <span class="number">10</span>;  <span class="comment">//解引用pa需要先确定pa指向内存的大小,否则无法确定解引用的结果,偏移也是,需要先知道偏移量,这里都需要先进行强制类型转换使得void*指针转变为特定类型的指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h2 id="野指针">野指针</h2>
<p><strong>野指针指的是指向不可用内存区域的指针</strong></p>
<p>举例:</p>
<ul>
<li>未被初始化的指针</li>
<li>数组越界访问(在一些OJ环境越界访问是不允许的)</li>
<li>指针指向的空间释放了
<ul>
<li>动态内存分配释放内存没有把NULL赋值给指向这块内存的指针,此时指针指向了不可访问的内存</li>
<li>指向销毁的局部变量和函数栈帧等</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">    *p=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问了不能访问的内存发生错误,会报段错误<code>:Segmentation fault</code></p>
<p><img data-src="/images/C语言指针学习笔记/20250529131103_013.png" alt="image-20250316105217704"  /></p>
<blockquote>
<p>什么是段错误？
段错误是操作系统检测到程序试图访问非法内存地址时发出的信号（通常是
SIGSEGV）。在现代操作系统中，内存被划分为不同的段（如代码段、数据段、堆、栈等），每个段有特定的权限（读、写、执行）。当程序违反这些权限或访问未分配的内存时，就会触发段错误。
比如常见的段错误:<strong>读写越界,修改只读内存</strong>(常见的几种)</p>
</blockquote>
<p><img data-src="/images/C语言指针学习笔记/20250529131103_014.png" alt="image-20250316104725445" style="zoom:67%;" /></p>
<blockquote>
<p><strong>注意</strong></p>
<p>定义指针的时候如果不初始化,把指针定义为NULL <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="assert断言">assert:断言</h2>
<blockquote>
<p><code>assert.h</code>头⽂件定义了宏 <code>assert()</code>
，⽤于在运⾏时确保程序符合指定条件，如果不符合，就报错终⽌运⾏。这个宏常常被称为<strong>“断言”</strong></p>
</blockquote>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131055_015.png"
alt="assert函数原型" />
<figcaption aria-hidden="true">assert函数原型</figcaption>
</figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131056_016.png"
alt="assert函数使用示例" />
<figcaption aria-hidden="true">assert函数使用示例</figcaption>
</figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131057_017.png"
alt="assert函数报错演示" />
<figcaption aria-hidden="true">assert函数报错演示</figcaption>
</figure>
<blockquote>
<p><strong>提示</strong></p>
<p>使用<code>assert()</code>函数在调试过程加入一些条件判断,可以鉴定程序是否符合预期运行.如果不符合预期程序就停止运行且显示错误位置和表达式</p>
<p>如果不需要<code>assert</code>,只需在定义宏<code>#define NDEDUG</code>即可跳过<code>assert</code>语句</p>
</blockquote>
<h2 id="万能指针和malloc函数">万能指针和malloc函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无类型指针称为万能指针:</span></span><br><span class="line"><span class="type">void</span>* p;   <span class="comment">//可以通过强制类型转换转换为某种类型指针:(int*)p转换为指向int数据类型的指针</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>重要</strong></p>
<p>malloc函数向系统申请内存空间,参数为申请内存空间(堆内存)字节大小,返回值为内存首元素的地址,由于不知道这块地址存放数据类型,故返回void*的指针,需要的时候强制转换成对应类型的指针</p>
</blockquote>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131106_018.png"
alt="malloc函数原型" />
<figcaption aria-hidden="true">malloc函数原型</figcaption>
</figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131107_019.png"
alt="动态内存分配示例" />
<figcaption aria-hidden="true">动态内存分配示例</figcaption>
</figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131108_020.png"
alt="malloc使用注意事项" />
<figcaption aria-hidden="true">malloc使用注意事项</figcaption>
</figure>
<blockquote>
<p><strong>警告</strong></p>
<p>申请完内存空间使用完后需要手动释放,用free函数释放手动申请的内存空间防止内存泄漏,同时把str指针赋值为NULL,因为内存已经释放,不对str赋值为NULL变成野指针(指向不可以内存空间的指针)</p>
</blockquote>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131103_021.png"
alt="free函数使用示例" />
<figcaption aria-hidden="true">free函数使用示例</figcaption>
</figure>
<blockquote>
<p><strong>警告</strong></p>
<p><code>malloc</code>分配内存空间是未初始化的垃圾值,需要先初始化,用<code>memset</code>函数</p>
</blockquote>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131106_022.png"
alt="memset函数使用方法" />
<figcaption aria-hidden="true">memset函数使用方法</figcaption>
</figure>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *output = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">memset</span>(output, <span class="string">&#x27;\0&#x27;</span>, <span class="number">100</span>);  <span class="comment">//将分配内存存储字符修改为&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure>
<p>或者用<code>calloc</code>函数分配内存空间</p>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131107_023.png"
alt="calloc函数使用示例" />
<figcaption aria-hidden="true">calloc函数使用示例</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *output = (<span class="type">char</span>*)<span class="built_in">calloc</span>(<span class="number">100</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>)); </span><br></pre></td></tr></table></figure>
<h2
id="对比malloc和calloc">对比<code>malloc</code>和<code>calloc</code></h2>
<p><strong>在 C 语言中，malloc 和 calloc
都是用于动态分配内存的函数，但它们在用法和行为上有一些关键区别。以下是两者的对比，特别是传参和功能的差异：</strong></p>
<h3 id="函数签名和传参">1. <strong>函数签名和传参</strong></h3>
<ul>
<li><p><code>malloc</code></p>
<ul>
<li><p>原型：<code>void *malloc(size_t size);</code></p></li>
<li><p>参数：只接受一个参数 size，表示要分配的字节数。</p></li>
<li><p>返回：指向分配内存的指针（类型为
void*，需要手动转换为目标类型）。</p></li>
<li><p>示例：</p>
<p><code>char *ptr = (char*)malloc(100); // 分配 100 字节</code></p></li>
<li><p>特点：分配的是一块连续的内存，size 是总字节数。</p></li>
</ul></li>
<li><p><code>calloc</code></p>
<ul>
<li><p>原型：<code>void *calloc(size_t num, size_t size);</code></p></li>
<li><p>参数：接受两个参数：</p>
<ul>
<li>num：要分配的元素个数。</li>
<li>size：每个元素的大小（以字节为单位）。</li>
</ul></li>
<li><p>返回：指向分配内存的指针（类型为
void*，同样需要手动转换）。</p></li>
<li><p>示例：</p>
<p><code>char *ptr = (char*)calloc(100, sizeof(char)); // 分配 100 个 char 大小的内存</code></p></li>
<li><p>特点：分配的内存大小是 num * size，并且会将所有字节初始化为
0。</p></li>
</ul></li>
</ul>
<h3 id="内存初始化">2. <strong>内存初始化</strong></h3>
<ul>
<li><p><code>malloc</code></p>
<ul>
<li><p>分配的内存内容是未初始化的，可能是随机值（“垃圾值”）。</p></li>
<li><p>如果需要初始化，需要手动调用 memset 或其他方法。</p></li>
<li><p>示例：</p>
<p><code>char *ptr = (char*)malloc(100); // ptr 的内容是未定义的 memset(ptr, '\0', 100); // 手动初始化为 '\0'</code></p></li>
</ul></li>
<li><p><code>calloc</code></p>
<ul>
<li><p>分配的内存会被自动初始化为 0（对于字符来说就是 ‘\0’）。</p></li>
<li><p>这是一个内置行为，无需额外操作。</p></li>
<li><p>示例：</p>
<p><code>char *ptr = (char*)calloc(100, sizeof(char)); // ptr 的 100 个字节已自动初始化为 '\0'</code></p></li>
</ul></li>
</ul>
<h3 id="使用场景">3. <strong>使用场景</strong></h3>
<ul>
<li><code>malloc</code>
<ul>
<li>适用于只需要分配内存、不关心初始值的情况。</li>
<li>性能略高于 <code>calloc</code>，因为不执行初始化操作。</li>
</ul></li>
<li><code>calloc</code>
<ul>
<li>适用于需要确保内存初始值为 0
的情况（例如字符串缓冲区或计数器数组）。</li>
<li>参数分离（num 和 size）使得分配多元素数组更直观。</li>
</ul></li>
</ul>
<h3 id="内存分配的等价性">4. <strong>内存分配的等价性</strong></h3>
<ul>
<li><p><code>malloc(100)</code> 和 <code>calloc(100, 1)</code>
在分配的总字节数上是等价的（都是 100 字节），但 <code>calloc</code>
会额外将内存清零。</p></li>
<li><p>示例：</p>
<p><code>char *m = (char*)malloc(100);           // 100 字节，未初始化 char *c = (char*)calloc(100, sizeof(char)); // 100 字节，初始化为 0</code></p></li>
</ul>
<h3 id="错误处理">5. <strong>错误处理</strong></h3>
<ul>
<li><p>两者在分配失败时都返回
<code>NULL</code>，这一点没有区别。</p></li>
<li><p>示例：</p>
<p><code>char *ptr = (char*)malloc(100); if (ptr == NULL) &#123;    // 分配失败 &#125;</code></p></li>
</ul>
<h3 id="总结表">总结表</h3>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 30%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr>
<th>特性</th>
<th><code>malloc</code></th>
<th><code>calloc</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>参数</strong></td>
<td>一个：size（总字节数）</td>
<td>两个：num（个数），size（每元素字节数）</td>
</tr>
<tr>
<td><strong>初始化</strong></td>
<td>不初始化，内容未定义</td>
<td>自动初始化为 0</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较快（无初始化开销）</td>
<td>稍慢（有初始化开销）</td>
</tr>
<tr>
<td><strong>典型用途</strong></td>
<td>通用内存分配</td>
<td>需要清零的数组或缓冲区</td>
</tr>
</tbody>
</table>
<h3 id="实际选择">实际选择</h3>
<ul>
<li>如果你只需要内存且不在乎初始值，用<code>malloc</code></li>
<li>如果需要内存清零（比如字符串或计数器），用 <code>calloc</code>
会更方便。</li>
</ul>
<h2
id="char-ch和char-arr区别"><code>char *ch和char arr[]</code>区别</h2>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131108_024.png"
alt="字符指针与字符数组的区别" />
<figcaption aria-hidden="true">字符指针与字符数组的区别</figcaption>
</figure>
<blockquote>
<p>把字符串常量赋值给数组(只有初始化的时候可以这样)会把这个字符串常量赋值到栈区,<strong>把整个字符串拷贝给数组</strong>,而把字符串常量赋值给指针变量,会把首元素地址赋值给指针,这个时候<strong>指针指向静态区的字符串常量</strong></p>
</blockquote>
<h2 id="函数指针">函数指针</h2>
<h3 id="函数指针定义">函数指针定义</h3>
<blockquote>
<p><strong>重要</strong></p>
<p>首先区分一下数组指针和函数指针,数组名退化和函数名退化规则</p>
<ul>
<li><p>数组名在除<code>&amp;arr</code>和<code>sizeof(arr)</code>之外会退化(<strong>隐式转换</strong>)为首元素地址,<code>type_t arr[len]</code>中<code>arr</code>从<code>type_t [len]</code>类型退化为<code>type_t *</code>类型,即退化为首元素的地址(指针)</p></li>
<li><p>而函数名有所不同除<code>&amp;function</code>和<code>sizeof(function)</code>外(这里补充一下对函数进行<code>sizeof(function)</code>是不合法的,因为标准禁止
<code>sizeof</code> 函数类型C11 §6.5.3.4/1 只允许对”对象”或完整的类型做
<code>sizeof，</code>函数既不是对象，也不是完整的可测类型,如果需要计算函数入口地址的大小可以<code>sizeof(&amp;fun)</code>,由于函数名在面对&amp;操作符的时候不会退化为入口地址,这个时候对函数名取地地址得到函数的入口地址,再用<code>sizeof</code>即可),<code>type_t function(parameter)</code>中<code>function</code>会从<code>type_t (parameter)</code>类型退化为(<strong>隐式转换</strong>)为<code>type_t (*)(parameter)</code>类型,表示的是函数的入口地址,我们又发现,不发生隐式转换的情况的是对函数取地址,其实对函数取地址<code>&amp;function</code>恰好是<code>type_t (*)(parameter)</code>类型,<strong>即<code>&amp;function</code>和<code>function</code>是等价的</strong>,这个是与数组不同的地方,原因是数组名和函数名隐式转换的类型不同,一个转换为首元素的地址,一个转换为<strong>函数入口地址</strong></p></li>
</ul>
</blockquote>
<p>⭐<code>&amp;fun</code>和<code>fun</code>是等价的(<strong>隐式转换的原因</strong>)</p>
<blockquote>
<p>根据前⾯学习整型指针，数组指针的时候，我们的类比关系，我们不难得出结论：<strong>函数指针变量应该是⽤来存放函数地址的，未来通过地址能够调⽤函数的</strong>。</p>
</blockquote>
<p>函数指针是变量存储函数的地址,对函数名取地址<code>&amp;function</code>得到函数的地址,这个与对数组名取地址得到数组的地址一致,这个时候需要用函数指针接收这个地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*p)()=test;  <span class="comment">//指向函数的指针(test和&amp;test等价,都是函数入口地址)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;test =%p\n&quot;</span>,&amp;test);   <span class="comment">//分别打印&amp;test,test,p的值发现三个值完全一样,</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test  =%p\n&quot;</span>,test);	   <span class="comment">//&amp;test函数的地址(入口地址),用函数指针的指针接收,</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p     =%p\n&quot;</span>,p);	   <span class="comment">//但是函数名又会退化为函数入口地址,所以test与&amp;test完全等价</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131109_025.png"
alt="函数指针地址等价性示例" />
<figcaption aria-hidden="true">函数指针地址等价性示例</figcaption>
</figure>
<blockquote>
<p><strong>提示</strong></p>
<p>类似数组指针,使用函数指针需要用到函数调用操作符<code>()</code>(使用数组指针使用的是数组下标运算符<code>[]</code>)</p>
</blockquote>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131111_026.png"
alt="函数指针调用方式" />
<figcaption aria-hidden="true">函数指针调用方式</figcaption>
</figure>
<blockquote>
<p><strong>提示</strong></p>
<p>注意函数指针定义的时候可以<strong>省略函数参数名,也可以不省略,没什么影响</strong>,反正使用函数指针调用函数的时候需要传实际参数,省不省略参数名参数名都不起作用</p>
</blockquote>
<h4 id="示例">示例</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> (*pf)(<span class="type">int</span>,<span class="type">int</span> )=add;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,pf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131112_027.png"
alt="函数指针和函数名地址值比较" />
<figcaption aria-hidden="true">函数指针和函数名地址值比较</figcaption>
</figure>
<p><strong>小结：</strong></p>
<ul>
<li><code>*add</code>
并不是一个新函数或特殊符号，只是”对函数指针解引用”→得到函数设计器→
再次退化成指针。</li>
<li>因此
<code>add</code>、<code>&amp;add</code>、<code>*add</code>、<code>pf</code>
在打印地址时都一样。</li>
</ul>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131113_028.png"
alt="函数指针解引用等价性" />
<figcaption aria-hidden="true">函数指针解引用等价性</figcaption>
</figure>
<h2 id="回调函数">回调函数</h2>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131116_029.png"
alt="回调函数定义" />
<figcaption aria-hidden="true">回调函数定义</figcaption>
</figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131117_030.png"
alt="回调函数示例" />
<figcaption aria-hidden="true">回调函数示例</figcaption>
</figure>
<h2 id="qsort函数"><code>qsort</code>函数</h2>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131120_031.png"
alt="qsort函数原型" />
<figcaption aria-hidden="true">qsort函数原型</figcaption>
</figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131121_032.png"
alt="qsort函数参数说明" />
<figcaption aria-hidden="true">qsort函数参数说明</figcaption>
</figure>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131122_033.png"
alt="qsort使用示例" />
<figcaption aria-hidden="true">qsort使用示例</figcaption>
</figure>
<p>运行结果 <img data-src="/images/C语言指针学习笔记/20250529131123_034.png"
alt="qsort排序结构体示例结果" /></p>
<p><u><strong>指针通关测试题</strong></u></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *c[] = &#123;<span class="string">&quot;ENTER&quot;</span>, <span class="string">&quot;NEW&quot;</span>, <span class="string">&quot;POINT&quot;</span>, <span class="string">&quot;FIRST&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> **cp[] = &#123;c + <span class="number">3</span>, c + <span class="number">2</span>, c + <span class="number">1</span>, c&#125;;</span><br><span class="line">    <span class="type">char</span> ***cpp = cp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, **++cpp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *--*++cpp + <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *cpp[<span class="number">-2</span>] + <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, cpp[<span class="number">-1</span>][<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong></p>
<figure>
<img data-src="/images/C语言指针学习笔记/20250529131124_035.png"
alt="多级指针测试题运行结果" />
<figcaption aria-hidden="true">多级指针测试题运行结果</figcaption>
</figure>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Hulu
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://blog.huluapple.xin/2025/05/29/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C语言指针学习笔记">https://blog.huluapple.xin/2025/05/29/C语言指针学习笔记/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag"># C语言</a>
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
              <a href="/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" rel="tag"># 技术分享</a>
              <a href="/tags/%E6%8C%87%E9%92%88/" rel="tag"># 指针</a>
              <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag"># 内存管理</a>
              <a href="/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" rel="tag"># 函数指针</a>
              <a href="/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" rel="tag"># 回调函数</a>
              <a href="/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag"># 动态内存分配</a>
              <a href="/tags/%E9%87%8E%E6%8C%87%E9%92%88/" rel="tag"># 野指针</a>
              <a href="/tags/const%E4%BF%AE%E9%A5%B0%E7%AC%A6/" rel="tag"># const修饰符</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/04/29/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/" rel="prev" title="C语言实现终端扫雷游戏">
                  <i class="fa fa-angle-left"></i> C语言实现终端扫雷游戏
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">true</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/"}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/fancybox.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"hulu798","repo":"hulu798.github.io","client_id":"Ov23liJZ8s2TeGX4QVJK","client_secret":"6b371a59456fe69b041dad82fb433d10ef00e0e5","admin_user":"hulu798","distraction_free_mode":true,"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","createIssueManually":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"16add2f5a1c1e060df5991994e820bdf"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
